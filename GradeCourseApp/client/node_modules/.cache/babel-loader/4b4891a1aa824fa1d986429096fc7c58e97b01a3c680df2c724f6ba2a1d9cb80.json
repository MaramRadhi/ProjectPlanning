{"ast":null,"code":"var RA_STORE = 'RaStore';\n// localStorage isn't available in incognito mode. We need to detect it\nvar testLocalStorage = function () {\n  // eslint-disable-next-line eqeqeq\n  if (typeof window === 'undefined' || window.localStorage == undefined) {\n    return false;\n  }\n  try {\n    window.localStorage.setItem('test', 'test');\n    window.localStorage.removeItem('test');\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nvar localStorageAvailable = testLocalStorage();\n/**\n * Store using localStorage, or memory storage in incognito mode\n *\n * @example\n *\n * import { localStorageStore } from 'react-admin';\n *\n * const App = () => (\n *    <Admin store={localStorageStore()}>\n *       ...\n *   </Admin>\n * );\n */\nexport var localStorageStore = function (version, appKey) {\n  if (version === void 0) {\n    version = '1';\n  }\n  if (appKey === void 0) {\n    appKey = '';\n  }\n  var prefix = \"\".concat(RA_STORE).concat(appKey);\n  var prefixLength = prefix.length;\n  var subscriptions = {};\n  var publish = function (key, value) {\n    Object.keys(subscriptions).forEach(function (id) {\n      if (!subscriptions[id]) return; // may happen if a component unmounts after a first subscriber was notified\n      if (subscriptions[id].key === key) {\n        subscriptions[id].callback(value);\n      }\n    });\n  };\n  // Whenever the local storage changes in another document, look for matching subscribers.\n  // This allows to synchronize state across tabs\n  var onLocalStorageChange = function (event) {\n    var _a;\n    if (((_a = event.key) === null || _a === void 0 ? void 0 : _a.substring(0, prefixLength)) !== prefix) {\n      return;\n    }\n    var key = event.key.substring(prefixLength + 1);\n    var value = event.newValue ? tryParse(event.newValue) : undefined;\n    Object.keys(subscriptions).forEach(function (id) {\n      if (!subscriptions[id]) return; // may happen if a component unmounts after a first subscriber was notified\n      if (subscriptions[id].key === key) {\n        if (value === null) {\n          // an event with a null value is sent when the key is deleted.\n          // to enable default value, we need to call setValue(undefined) instead of setValue(null)\n          subscriptions[id].callback(undefined);\n        } else {\n          subscriptions[id].callback(value == null ? undefined : value);\n        }\n      }\n    });\n  };\n  return {\n    setup: function () {\n      if (localStorageAvailable) {\n        var storedVersion = getStorage().getItem(\"\".concat(prefix, \".version\"));\n        if (storedVersion && storedVersion !== version) {\n          var storage_1 = getStorage();\n          Object.keys(storage_1).forEach(function (key) {\n            if (key.startsWith(prefix)) {\n              storage_1.removeItem(key);\n            }\n          });\n        }\n        getStorage().setItem(\"\".concat(prefix, \".version\"), version);\n        window.addEventListener('storage', onLocalStorageChange);\n      }\n    },\n    teardown: function () {\n      if (localStorageAvailable) {\n        window.removeEventListener('storage', onLocalStorageChange);\n      }\n    },\n    getItem: function (key, defaultValue) {\n      var valueFromStorage = getStorage().getItem(\"\".concat(prefix, \".\").concat(key));\n      // eslint-disable-next-line eqeqeq\n      return valueFromStorage == null ? defaultValue : tryParse(valueFromStorage);\n    },\n    setItem: function (key, value) {\n      if (value === undefined) {\n        getStorage().removeItem(\"\".concat(prefix, \".\").concat(key));\n      } else {\n        getStorage().setItem(\"\".concat(prefix, \".\").concat(key), JSON.stringify(value));\n      }\n      publish(key, value);\n    },\n    removeItem: function (key) {\n      getStorage().removeItem(\"\".concat(prefix, \".\").concat(key));\n      publish(key, undefined);\n    },\n    removeItems: function (keyPrefix) {\n      var storage = getStorage();\n      Object.keys(storage).forEach(function (key) {\n        if (key.startsWith(\"\".concat(prefix, \".\").concat(keyPrefix))) {\n          storage.removeItem(key);\n          var publishKey = key.substring(prefixLength + 1);\n          publish(publishKey, undefined);\n        }\n      });\n    },\n    reset: function () {\n      var storage = getStorage();\n      Object.keys(storage).forEach(function (key) {\n        if (key.startsWith(prefix)) {\n          storage.removeItem(key);\n          var publishKey = key.substring(prefixLength + 1);\n          publish(publishKey, undefined);\n        }\n      });\n    },\n    subscribe: function (key, callback) {\n      var id = Math.random().toString();\n      subscriptions[id] = {\n        key: key,\n        callback: callback\n      };\n      return function () {\n        delete subscriptions[id];\n      };\n    }\n  };\n};\nvar tryParse = function (value) {\n  try {\n    return JSON.parse(value);\n  } catch (e) {\n    return value;\n  }\n};\nvar LocalStorageShim = /** @class */function () {\n  function LocalStorageShim() {\n    this.valuesMap = new Map();\n  }\n  LocalStorageShim.prototype.getItem = function (key) {\n    if (this.valuesMap.has(key)) {\n      return String(this.valuesMap.get(key));\n    }\n    return null;\n  };\n  LocalStorageShim.prototype.setItem = function (key, value) {\n    this.valuesMap.set(key, value);\n  };\n  LocalStorageShim.prototype.removeItem = function (key) {\n    this.valuesMap.delete(key);\n  };\n  LocalStorageShim.prototype.removeItems = function (keyPrefix) {\n    var _this = this;\n    this.valuesMap.forEach(function (value, key) {\n      if (key.startsWith(keyPrefix)) {\n        _this.valuesMap.delete(key);\n      }\n    });\n  };\n  LocalStorageShim.prototype.clear = function () {\n    this.valuesMap.clear();\n  };\n  LocalStorageShim.prototype.key = function (i) {\n    if (arguments.length === 0) {\n      throw new TypeError(\"Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.\"); // this is a TypeError implemented on Chrome, Firefox throws Not enough arguments to Storage.key.\n    }\n\n    var arr = Array.from(this.valuesMap.keys());\n    return arr[i];\n  };\n  Object.defineProperty(LocalStorageShim.prototype, \"length\", {\n    get: function () {\n      return this.valuesMap.size;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return LocalStorageShim;\n}();\nvar memoryStorage = new LocalStorageShim();\nexport var getStorage = function () {\n  return localStorageAvailable ? window.localStorage : memoryStorage;\n};","map":{"version":3,"names":["RA_STORE","testLocalStorage","window","localStorage","undefined","setItem","removeItem","e","localStorageAvailable","localStorageStore","version","appKey","prefix","concat","prefixLength","length","subscriptions","publish","key","value","Object","keys","forEach","id","callback","onLocalStorageChange","event","_a","substring","newValue","tryParse","setup","storedVersion","getStorage","getItem","storage_1","startsWith","addEventListener","teardown","removeEventListener","defaultValue","valueFromStorage","JSON","stringify","removeItems","keyPrefix","storage","publishKey","reset","subscribe","Math","random","toString","parse","LocalStorageShim","valuesMap","Map","prototype","has","String","get","set","delete","_this","clear","i","arguments","TypeError","arr","Array","from","defineProperty","size","memoryStorage"],"sources":["/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/ra-core/src/store/localStorageStore.ts"],"sourcesContent":["import { Store } from './types';\n\ntype Subscription = {\n    key: string;\n    callback: (value: any) => void;\n};\n\nconst RA_STORE = 'RaStore';\n\n// localStorage isn't available in incognito mode. We need to detect it\nconst testLocalStorage = () => {\n    // eslint-disable-next-line eqeqeq\n    if (typeof window === 'undefined' || window.localStorage == undefined) {\n        return false;\n    }\n\n    try {\n        window.localStorage.setItem('test', 'test');\n        window.localStorage.removeItem('test');\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\n\nlet localStorageAvailable = testLocalStorage();\n\n/**\n * Store using localStorage, or memory storage in incognito mode\n *\n * @example\n *\n * import { localStorageStore } from 'react-admin';\n *\n * const App = () => (\n *    <Admin store={localStorageStore()}>\n *       ...\n *   </Admin>\n * );\n */\nexport const localStorageStore = (\n    version: string = '1',\n    appKey: string = ''\n): Store => {\n    const prefix = `${RA_STORE}${appKey}`;\n    const prefixLength = prefix.length;\n    const subscriptions: { [key: string]: Subscription } = {};\n    const publish = (key: string, value: any) => {\n        Object.keys(subscriptions).forEach(id => {\n            if (!subscriptions[id]) return; // may happen if a component unmounts after a first subscriber was notified\n            if (subscriptions[id].key === key) {\n                subscriptions[id].callback(value);\n            }\n        });\n    };\n\n    // Whenever the local storage changes in another document, look for matching subscribers.\n    // This allows to synchronize state across tabs\n    const onLocalStorageChange = (event: StorageEvent): void => {\n        if (event.key?.substring(0, prefixLength) !== prefix) {\n            return;\n        }\n        const key = event.key.substring(prefixLength + 1);\n        const value = event.newValue ? tryParse(event.newValue) : undefined;\n        Object.keys(subscriptions).forEach(id => {\n            if (!subscriptions[id]) return; // may happen if a component unmounts after a first subscriber was notified\n            if (subscriptions[id].key === key) {\n                if (value === null) {\n                    // an event with a null value is sent when the key is deleted.\n                    // to enable default value, we need to call setValue(undefined) instead of setValue(null)\n                    subscriptions[id].callback(undefined);\n                } else {\n                    subscriptions[id].callback(\n                        value == null ? undefined : value\n                    );\n                }\n            }\n        });\n    };\n\n    return {\n        setup: () => {\n            if (localStorageAvailable) {\n                const storedVersion = getStorage().getItem(`${prefix}.version`);\n                if (storedVersion && storedVersion !== version) {\n                    const storage = getStorage();\n                    Object.keys(storage).forEach(key => {\n                        if (key.startsWith(prefix)) {\n                            storage.removeItem(key);\n                        }\n                    });\n                }\n                getStorage().setItem(`${prefix}.version`, version);\n                window.addEventListener('storage', onLocalStorageChange);\n            }\n        },\n        teardown: () => {\n            if (localStorageAvailable) {\n                window.removeEventListener('storage', onLocalStorageChange);\n            }\n        },\n        getItem<T = any>(key: string, defaultValue?: T): T {\n            const valueFromStorage = getStorage().getItem(`${prefix}.${key}`);\n\n            // eslint-disable-next-line eqeqeq\n            return valueFromStorage == null\n                ? defaultValue\n                : tryParse(valueFromStorage);\n        },\n        setItem<T = any>(key: string, value: T): void {\n            if (value === undefined) {\n                getStorage().removeItem(`${prefix}.${key}`);\n            } else {\n                getStorage().setItem(`${prefix}.${key}`, JSON.stringify(value));\n            }\n            publish(key, value);\n        },\n        removeItem(key: string): void {\n            getStorage().removeItem(`${prefix}.${key}`);\n            publish(key, undefined);\n        },\n        removeItems(keyPrefix: string): void {\n            const storage = getStorage();\n            Object.keys(storage).forEach(key => {\n                if (key.startsWith(`${prefix}.${keyPrefix}`)) {\n                    storage.removeItem(key);\n                    const publishKey = key.substring(prefixLength + 1);\n                    publish(publishKey, undefined);\n                }\n            });\n        },\n        reset(): void {\n            const storage = getStorage();\n            Object.keys(storage).forEach(key => {\n                if (key.startsWith(prefix)) {\n                    storage.removeItem(key);\n                    const publishKey = key.substring(prefixLength + 1);\n                    publish(publishKey, undefined);\n                }\n            });\n        },\n        subscribe: (key: string, callback: (value: string) => void) => {\n            const id = Math.random().toString();\n            subscriptions[id] = {\n                key,\n                callback,\n            };\n            return () => {\n                delete subscriptions[id];\n            };\n        },\n    };\n};\n\nconst tryParse = (value: string): any => {\n    try {\n        return JSON.parse(value);\n    } catch (e) {\n        return value;\n    }\n};\nclass LocalStorageShim {\n    valuesMap: any = new Map();\n\n    getItem(key: string) {\n        if (this.valuesMap.has(key)) {\n            return String(this.valuesMap.get(key));\n        }\n        return null;\n    }\n\n    setItem(key: string, value: string) {\n        this.valuesMap.set(key, value);\n    }\n\n    removeItem(key: string) {\n        this.valuesMap.delete(key);\n    }\n\n    removeItems(keyPrefix: string) {\n        this.valuesMap.forEach((value, key) => {\n            if (key.startsWith(keyPrefix)) {\n                this.valuesMap.delete(key);\n            }\n        });\n    }\n\n    clear() {\n        this.valuesMap.clear();\n    }\n\n    key(i): string {\n        if (arguments.length === 0) {\n            throw new TypeError(\n                \"Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.\"\n            ); // this is a TypeError implemented on Chrome, Firefox throws Not enough arguments to Storage.key.\n        }\n        const arr = Array.from(this.valuesMap.keys()) as string[];\n        return arr[i];\n    }\n\n    get length() {\n        return this.valuesMap.size;\n    }\n}\nconst memoryStorage = new LocalStorageShim();\n\nexport const getStorage = () => {\n    return localStorageAvailable ? window.localStorage : memoryStorage;\n};\n"],"mappings":"AAOA,IAAMA,QAAQ,GAAG,SAAS;AAE1B;AACA,IAAMC,gBAAgB,GAAG,SAAAA,CAAA;EACrB;EACA,IAAI,OAAOC,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACC,YAAY,IAAIC,SAAS,EAAE;IACnE,OAAO,KAAK;;EAGhB,IAAI;IACAF,MAAM,CAACC,YAAY,CAACE,OAAO,CAAC,MAAM,EAAE,MAAM,CAAC;IAC3CH,MAAM,CAACC,YAAY,CAACG,UAAU,CAAC,MAAM,CAAC;IACtC,OAAO,IAAI;GACd,CAAC,OAAOC,CAAC,EAAE;IACR,OAAO,KAAK;;AAEpB,CAAC;AAED,IAAIC,qBAAqB,GAAGP,gBAAgB,EAAE;AAE9C;;;;;;;;;;;;;AAaA,OAAO,IAAMQ,iBAAiB,GAAG,SAAAA,CAC7BC,OAAqB,EACrBC,MAAmB;EADnB,IAAAD,OAAA;IAAAA,OAAA,MAAqB;EAAA;EACrB,IAAAC,MAAA;IAAAA,MAAA,KAAmB;EAAA;EAEnB,IAAMC,MAAM,GAAG,GAAAC,MAAA,CAAGb,QAAQ,EAAAa,MAAA,CAAGF,MAAM,CAAE;EACrC,IAAMG,YAAY,GAAGF,MAAM,CAACG,MAAM;EAClC,IAAMC,aAAa,GAAoC,EAAE;EACzD,IAAMC,OAAO,GAAG,SAAAA,CAACC,GAAW,EAAEC,KAAU;IACpCC,MAAM,CAACC,IAAI,CAACL,aAAa,CAAC,CAACM,OAAO,CAAC,UAAAC,EAAE;MACjC,IAAI,CAACP,aAAa,CAACO,EAAE,CAAC,EAAE,OAAO,CAAC;MAChC,IAAIP,aAAa,CAACO,EAAE,CAAC,CAACL,GAAG,KAAKA,GAAG,EAAE;QAC/BF,aAAa,CAACO,EAAE,CAAC,CAACC,QAAQ,CAACL,KAAK,CAAC;;IAEzC,CAAC,CAAC;EACN,CAAC;EAED;EACA;EACA,IAAMM,oBAAoB,GAAG,SAAAA,CAACC,KAAmB;;IAC7C,IAAI,EAAAC,EAAA,GAAAD,KAAK,CAACR,GAAG,cAAAS,EAAA,uBAAAA,EAAA,CAAEC,SAAS,CAAC,CAAC,EAAEd,YAAY,CAAC,MAAKF,MAAM,EAAE;MAClD;;IAEJ,IAAMM,GAAG,GAAGQ,KAAK,CAACR,GAAG,CAACU,SAAS,CAACd,YAAY,GAAG,CAAC,CAAC;IACjD,IAAMK,KAAK,GAAGO,KAAK,CAACG,QAAQ,GAAGC,QAAQ,CAACJ,KAAK,CAACG,QAAQ,CAAC,GAAGzB,SAAS;IACnEgB,MAAM,CAACC,IAAI,CAACL,aAAa,CAAC,CAACM,OAAO,CAAC,UAAAC,EAAE;MACjC,IAAI,CAACP,aAAa,CAACO,EAAE,CAAC,EAAE,OAAO,CAAC;MAChC,IAAIP,aAAa,CAACO,EAAE,CAAC,CAACL,GAAG,KAAKA,GAAG,EAAE;QAC/B,IAAIC,KAAK,KAAK,IAAI,EAAE;UAChB;UACA;UACAH,aAAa,CAACO,EAAE,CAAC,CAACC,QAAQ,CAACpB,SAAS,CAAC;SACxC,MAAM;UACHY,aAAa,CAACO,EAAE,CAAC,CAACC,QAAQ,CACtBL,KAAK,IAAI,IAAI,GAAGf,SAAS,GAAGe,KAAK,CACpC;;;IAGb,CAAC,CAAC;EACN,CAAC;EAED,OAAO;IACHY,KAAK,EAAE,SAAAA,CAAA;MACH,IAAIvB,qBAAqB,EAAE;QACvB,IAAMwB,aAAa,GAAGC,UAAU,EAAE,CAACC,OAAO,CAAC,GAAArB,MAAA,CAAGD,MAAM,aAAU,CAAC;QAC/D,IAAIoB,aAAa,IAAIA,aAAa,KAAKtB,OAAO,EAAE;UAC5C,IAAMyB,SAAO,GAAGF,UAAU,EAAE;UAC5Bb,MAAM,CAACC,IAAI,CAACc,SAAO,CAAC,CAACb,OAAO,CAAC,UAAAJ,GAAG;YAC5B,IAAIA,GAAG,CAACkB,UAAU,CAACxB,MAAM,CAAC,EAAE;cACxBuB,SAAO,CAAC7B,UAAU,CAACY,GAAG,CAAC;;UAE/B,CAAC,CAAC;;QAENe,UAAU,EAAE,CAAC5B,OAAO,CAAC,GAAAQ,MAAA,CAAGD,MAAM,aAAU,EAAEF,OAAO,CAAC;QAClDR,MAAM,CAACmC,gBAAgB,CAAC,SAAS,EAAEZ,oBAAoB,CAAC;;IAEhE,CAAC;IACDa,QAAQ,EAAE,SAAAA,CAAA;MACN,IAAI9B,qBAAqB,EAAE;QACvBN,MAAM,CAACqC,mBAAmB,CAAC,SAAS,EAAEd,oBAAoB,CAAC;;IAEnE,CAAC;IACDS,OAAO,WAAAA,CAAUhB,GAAW,EAAEsB,YAAgB;MAC1C,IAAMC,gBAAgB,GAAGR,UAAU,EAAE,CAACC,OAAO,CAAC,GAAArB,MAAA,CAAGD,MAAM,OAAAC,MAAA,CAAIK,GAAG,CAAE,CAAC;MAEjE;MACA,OAAOuB,gBAAgB,IAAI,IAAI,GACzBD,YAAY,GACZV,QAAQ,CAACW,gBAAgB,CAAC;IACpC,CAAC;IACDpC,OAAO,WAAAA,CAAUa,GAAW,EAAEC,KAAQ;MAClC,IAAIA,KAAK,KAAKf,SAAS,EAAE;QACrB6B,UAAU,EAAE,CAAC3B,UAAU,CAAC,GAAAO,MAAA,CAAGD,MAAM,OAAAC,MAAA,CAAIK,GAAG,CAAE,CAAC;OAC9C,MAAM;QACHe,UAAU,EAAE,CAAC5B,OAAO,CAAC,GAAAQ,MAAA,CAAGD,MAAM,OAAAC,MAAA,CAAIK,GAAG,CAAE,EAAEwB,IAAI,CAACC,SAAS,CAACxB,KAAK,CAAC,CAAC;;MAEnEF,OAAO,CAACC,GAAG,EAAEC,KAAK,CAAC;IACvB,CAAC;IACDb,UAAU,WAAAA,CAACY,GAAW;MAClBe,UAAU,EAAE,CAAC3B,UAAU,CAAC,GAAAO,MAAA,CAAGD,MAAM,OAAAC,MAAA,CAAIK,GAAG,CAAE,CAAC;MAC3CD,OAAO,CAACC,GAAG,EAAEd,SAAS,CAAC;IAC3B,CAAC;IACDwC,WAAW,WAAAA,CAACC,SAAiB;MACzB,IAAMC,OAAO,GAAGb,UAAU,EAAE;MAC5Bb,MAAM,CAACC,IAAI,CAACyB,OAAO,CAAC,CAACxB,OAAO,CAAC,UAAAJ,GAAG;QAC5B,IAAIA,GAAG,CAACkB,UAAU,CAAC,GAAAvB,MAAA,CAAGD,MAAM,OAAAC,MAAA,CAAIgC,SAAS,CAAE,CAAC,EAAE;UAC1CC,OAAO,CAACxC,UAAU,CAACY,GAAG,CAAC;UACvB,IAAM6B,UAAU,GAAG7B,GAAG,CAACU,SAAS,CAACd,YAAY,GAAG,CAAC,CAAC;UAClDG,OAAO,CAAC8B,UAAU,EAAE3C,SAAS,CAAC;;MAEtC,CAAC,CAAC;IACN,CAAC;IACD4C,KAAK,WAAAA,CAAA;MACD,IAAMF,OAAO,GAAGb,UAAU,EAAE;MAC5Bb,MAAM,CAACC,IAAI,CAACyB,OAAO,CAAC,CAACxB,OAAO,CAAC,UAAAJ,GAAG;QAC5B,IAAIA,GAAG,CAACkB,UAAU,CAACxB,MAAM,CAAC,EAAE;UACxBkC,OAAO,CAACxC,UAAU,CAACY,GAAG,CAAC;UACvB,IAAM6B,UAAU,GAAG7B,GAAG,CAACU,SAAS,CAACd,YAAY,GAAG,CAAC,CAAC;UAClDG,OAAO,CAAC8B,UAAU,EAAE3C,SAAS,CAAC;;MAEtC,CAAC,CAAC;IACN,CAAC;IACD6C,SAAS,EAAE,SAAAA,CAAC/B,GAAW,EAAEM,QAAiC;MACtD,IAAMD,EAAE,GAAG2B,IAAI,CAACC,MAAM,EAAE,CAACC,QAAQ,EAAE;MACnCpC,aAAa,CAACO,EAAE,CAAC,GAAG;QAChBL,GAAG,EAAAA,GAAA;QACHM,QAAQ,EAAAA;OACX;MACD,OAAO;QACH,OAAOR,aAAa,CAACO,EAAE,CAAC;MAC5B,CAAC;IACL;GACH;AACL,CAAC;AAED,IAAMO,QAAQ,GAAG,SAAAA,CAACX,KAAa;EAC3B,IAAI;IACA,OAAOuB,IAAI,CAACW,KAAK,CAAClC,KAAK,CAAC;GAC3B,CAAC,OAAOZ,CAAC,EAAE;IACR,OAAOY,KAAK;;AAEpB,CAAC;AACD,IAAAmC,gBAAA;EAAA,SAAAA,iBAAA;IACI,KAAAC,SAAS,GAAQ,IAAIC,GAAG,EAAE;EA0C9B;EAxCIF,gBAAA,CAAAG,SAAA,CAAAvB,OAAO,GAAP,UAAQhB,GAAW;IACf,IAAI,IAAI,CAACqC,SAAS,CAACG,GAAG,CAACxC,GAAG,CAAC,EAAE;MACzB,OAAOyC,MAAM,CAAC,IAAI,CAACJ,SAAS,CAACK,GAAG,CAAC1C,GAAG,CAAC,CAAC;;IAE1C,OAAO,IAAI;EACf,CAAC;EAEDoC,gBAAA,CAAAG,SAAA,CAAApD,OAAO,GAAP,UAAQa,GAAW,EAAEC,KAAa;IAC9B,IAAI,CAACoC,SAAS,CAACM,GAAG,CAAC3C,GAAG,EAAEC,KAAK,CAAC;EAClC,CAAC;EAEDmC,gBAAA,CAAAG,SAAA,CAAAnD,UAAU,GAAV,UAAWY,GAAW;IAClB,IAAI,CAACqC,SAAS,CAACO,MAAM,CAAC5C,GAAG,CAAC;EAC9B,CAAC;EAEDoC,gBAAA,CAAAG,SAAA,CAAAb,WAAW,GAAX,UAAYC,SAAiB;IAA7B,IAAAkB,KAAA;IACI,IAAI,CAACR,SAAS,CAACjC,OAAO,CAAC,UAACH,KAAK,EAAED,GAAG;MAC9B,IAAIA,GAAG,CAACkB,UAAU,CAACS,SAAS,CAAC,EAAE;QAC3BkB,KAAI,CAACR,SAAS,CAACO,MAAM,CAAC5C,GAAG,CAAC;;IAElC,CAAC,CAAC;EACN,CAAC;EAEDoC,gBAAA,CAAAG,SAAA,CAAAO,KAAK,GAAL;IACI,IAAI,CAACT,SAAS,CAACS,KAAK,EAAE;EAC1B,CAAC;EAEDV,gBAAA,CAAAG,SAAA,CAAAvC,GAAG,GAAH,UAAI+C,CAAC;IACD,IAAIC,SAAS,CAACnD,MAAM,KAAK,CAAC,EAAE;MACxB,MAAM,IAAIoD,SAAS,CACf,gFAAgF,CACnF,CAAC,CAAC;;;IAEP,IAAMC,GAAG,GAAGC,KAAK,CAACC,IAAI,CAAC,IAAI,CAACf,SAAS,CAAClC,IAAI,EAAE,CAAa;IACzD,OAAO+C,GAAG,CAACH,CAAC,CAAC;EACjB,CAAC;EAED7C,MAAA,CAAAmD,cAAA,CAAIjB,gBAAA,CAAAG,SAAA,UAAM;SAAV,SAAAG,CAAA;MACI,OAAO,IAAI,CAACL,SAAS,CAACiB,IAAI;IAC9B,CAAC;;;;EACL,OAAAlB,gBAAC;AAAD,CAAC,EA3CD;AA4CA,IAAMmB,aAAa,GAAG,IAAInB,gBAAgB,EAAE;AAE5C,OAAO,IAAMrB,UAAU,GAAG,SAAAA,CAAA;EACtB,OAAOzB,qBAAqB,GAAGN,MAAM,CAACC,YAAY,GAAGsE,aAAa;AACtE,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}