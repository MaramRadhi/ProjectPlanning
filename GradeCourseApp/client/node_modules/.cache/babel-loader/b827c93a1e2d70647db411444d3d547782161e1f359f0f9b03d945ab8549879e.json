{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useCallback, isValidElement } from 'react';\nimport set from 'lodash/set';\nimport { useChoices } from './useChoices';\nimport { useTranslate } from '../i18n';\n/*\n * Returns helper functions for suggestions handling.\n *\n * @param allowDuplicates A boolean indicating whether a suggestion can be added several times\n * @param choices An array of available choices\n * @param limitChoicesToValue A boolean indicating whether the initial suggestions should be limited to the currently selected one(s)\n * @param matchSuggestion Optional unless `optionText` is a React element. Function which check whether a choice matches a filter. Must return a boolean.\n * @param optionText Either a string defining the property to use to get the choice text, a function or a React element\n * @param optionValue The property to use to get the choice value\n * @param selectedItem The currently selected item. Maybe an array of selected items\n * @param suggestionLimit The maximum number of suggestions returned\n * @param translateChoice A boolean indicating whether to option text should be translated\n *\n * @returns An object with helper functions:\n * - getChoiceText: Returns the choice text or a React element\n * - getChoiceValue: Returns the choice value\n * - getSuggestions: A function taking a filter value (string) and returning the matching suggestions\n */\nexport var useSuggestions = function (_a) {\n  var allowCreate = _a.allowCreate,\n    choices = _a.choices,\n    _b = _a.createText,\n    createText = _b === void 0 ? 'ra.action.create' : _b,\n    _c = _a.createValue,\n    createValue = _c === void 0 ? '@@create' : _c,\n    limitChoicesToValue = _a.limitChoicesToValue,\n    matchSuggestion = _a.matchSuggestion,\n    optionText = _a.optionText,\n    optionValue = _a.optionValue,\n    selectedItem = _a.selectedItem,\n    _d = _a.suggestionLimit,\n    suggestionLimit = _d === void 0 ? 0 : _d,\n    translateChoice = _a.translateChoice;\n  var translate = useTranslate();\n  var _e = useChoices({\n      optionText: optionText,\n      optionValue: optionValue,\n      translateChoice: translateChoice\n    }),\n    getChoiceText = _e.getChoiceText,\n    getChoiceValue = _e.getChoiceValue;\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  var getSuggestions = useCallback(getSuggestionsFactory({\n    allowCreate: allowCreate,\n    choices: choices,\n    createText: createText,\n    createValue: createValue,\n    getChoiceText: getChoiceText,\n    getChoiceValue: getChoiceValue,\n    limitChoicesToValue: limitChoicesToValue,\n    matchSuggestion: matchSuggestion,\n    optionText: optionText,\n    optionValue: optionValue,\n    selectedItem: selectedItem,\n    suggestionLimit: suggestionLimit\n  }), [allowCreate, choices, createText, createValue, getChoiceText, getChoiceValue, limitChoicesToValue, matchSuggestion, optionText, optionValue, selectedItem, suggestionLimit, translate]);\n  return {\n    getChoiceText: getChoiceText,\n    getChoiceValue: getChoiceValue,\n    getSuggestions: getSuggestions\n  };\n};\nvar escapeRegExp = function (value) {\n  return value ? value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') : '';\n}; // $& means the whole matched string\n/**\n * Default matcher implementation which check whether the suggestion text matches the filter.\n */\nvar defaultMatchSuggestion = function (getChoiceText) {\n  return function (filter, suggestion, exact) {\n    if (exact === void 0) {\n      exact = false;\n    }\n    var suggestionText = getChoiceText(suggestion);\n    var isReactElement = isValidElement(suggestionText);\n    var regex = escapeRegExp(filter);\n    return isReactElement ? false : suggestionText && !!suggestionText.match(\n    // We must escape any RegExp reserved characters to avoid errors\n    // For example, the filter might contain * which must be escaped as \\*\n    new RegExp(exact ? \"^\".concat(regex, \"$\") : regex, 'i'));\n  };\n};\n/**\n * Get the suggestions to display after applying a fuzzy search on the available choices\n *\n * @example\n *\n * getSuggestions({\n *   choices: [{ id: 1, name: 'admin' }, { id: 2, name: 'publisher' }],\n *   optionText: 'name',\n *   optionValue: 'id',\n *   getSuggestionText: choice => choice[optionText],\n * })('pub')\n *\n * // Will return [{ id: 2, name: 'publisher' }]\n * getSuggestions({\n *   choices: [{ id: 1, name: 'admin' }, { id: 2, name: 'publisher' }],\n *   optionText: 'name',\n *   optionValue: 'id',\n *   getSuggestionText: choice => choice[optionText],\n * })('pub')\n *\n * // Will return [{ id: 2, name: 'publisher' }]\n */\nexport var getSuggestionsFactory = function (_a) {\n  var _b = _a.allowCreate,\n    allowCreate = _b === void 0 ? false : _b,\n    _c = _a.choices,\n    choices = _c === void 0 ? [] : _c,\n    _d = _a.createText,\n    createText = _d === void 0 ? 'ra.action.create' : _d,\n    _e = _a.createValue,\n    createValue = _e === void 0 ? '@@create' : _e,\n    _f = _a.optionText,\n    optionText = _f === void 0 ? 'name' : _f,\n    _g = _a.optionValue,\n    optionValue = _g === void 0 ? 'id' : _g,\n    getChoiceText = _a.getChoiceText,\n    getChoiceValue = _a.getChoiceValue,\n    _h = _a.limitChoicesToValue,\n    limitChoicesToValue = _h === void 0 ? false : _h,\n    _j = _a.matchSuggestion,\n    matchSuggestion = _j === void 0 ? defaultMatchSuggestion(getChoiceText) : _j,\n    selectedItem = _a.selectedItem,\n    _k = _a.suggestionLimit,\n    suggestionLimit = _k === void 0 ? 0 : _k;\n  return function (filter) {\n    var suggestions = [];\n    // if an item is selected and matches the filter\n    if (selectedItem && !Array.isArray(selectedItem) && matchSuggestion(filter, selectedItem)) {\n      if (limitChoicesToValue) {\n        // display only the selected item\n        suggestions = choices.filter(function (choice) {\n          return getChoiceValue(choice) === getChoiceValue(selectedItem);\n        });\n      } else {\n        suggestions = __spreadArray([], choices, true);\n      }\n    } else {\n      suggestions = choices.filter(function (choice) {\n        return matchSuggestion(filter, choice) || selectedItem != null && (!Array.isArray(selectedItem) ? getChoiceValue(choice) === getChoiceValue(selectedItem) : selectedItem.some(function (selected) {\n          return getChoiceValue(choice) === getChoiceValue(selected);\n        }));\n      });\n    }\n    suggestions = limitSuggestions(suggestions, suggestionLimit);\n    var hasExactMatch = suggestions.some(function (suggestion) {\n      return matchSuggestion(filter, suggestion, true);\n    });\n    if (allowCreate) {\n      var filterIsSelectedItem =\n      // If the selectedItem is an array (for example AutocompleteArrayInput)\n      // we shouldn't try to match\n      !!selectedItem && !Array.isArray(selectedItem) ? matchSuggestion(filter, selectedItem, true) : false;\n      if (!hasExactMatch && !filterIsSelectedItem) {\n        suggestions.push(getSuggestion({\n          optionText: optionText,\n          optionValue: optionValue,\n          text: createText,\n          value: createValue\n        }));\n      }\n    }\n    // Only keep unique items. Necessary because we might have fetched\n    // the currently selected choice in addition of the possible choices\n    // that may also contain it\n    var result = suggestions.filter(function (suggestion, index) {\n      return suggestions.indexOf(suggestion) === index;\n    });\n    return result;\n  };\n};\n/**\n * @example\n *\n * limitSuggestions(\n *  [{ id: 1, name: 'foo'}, { id: 2, name: 'bar' }],\n *  1\n * );\n *\n * // Will return [{ id: 1, name: 'foo' }]\n *\n * @param suggestions List of suggestions\n * @param limit\n */\nvar limitSuggestions = function (suggestions, limit) {\n  if (limit === void 0) {\n    limit = 0;\n  }\n  return Number.isInteger(limit) && limit > 0 ? suggestions.slice(0, limit) : suggestions;\n};\n/**\n * addSuggestion(\n *  [{ id: 1, name: 'foo'}, { id: 2, name: 'bar' }],\n * );\n *\n * // Will return [{ id: null, name: '' }, { id: 1, name: 'foo' }, { id: 2, name: 'bar' }]\n *\n * @param suggestions List of suggestions\n * @param options\n * @param options.optionText\n */\nvar getSuggestion = function (_a) {\n  var _b = _a.optionText,\n    optionText = _b === void 0 ? 'name' : _b,\n    _c = _a.optionValue,\n    optionValue = _c === void 0 ? 'id' : _c,\n    _d = _a.text,\n    text = _d === void 0 ? '' : _d,\n    _e = _a.value,\n    value = _e === void 0 ? null : _e;\n  var suggestion = {};\n  set(suggestion, optionValue, value);\n  if (typeof optionText === 'string') {\n    set(suggestion, optionText, text);\n  }\n  return suggestion;\n};","map":{"version":3,"names":["useCallback","isValidElement","set","useChoices","useTranslate","useSuggestions","_a","allowCreate","choices","_b","createText","_c","createValue","limitChoicesToValue","matchSuggestion","optionText","optionValue","selectedItem","_d","suggestionLimit","translateChoice","translate","_e","getChoiceText","getChoiceValue","getSuggestions","getSuggestionsFactory","escapeRegExp","value","replace","defaultMatchSuggestion","filter","suggestion","exact","suggestionText","isReactElement","regex","match","RegExp","concat","_f","_g","_h","_j","_k","suggestions","Array","isArray","choice","__spreadArray","some","selected","limitSuggestions","hasExactMatch","filterIsSelectedItem","push","getSuggestion","text","result","index","indexOf","limit","Number","isInteger","slice"],"sources":["/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/ra-core/src/form/useSuggestions.ts"],"sourcesContent":["import { useCallback, isValidElement, ReactElement } from 'react';\nimport set from 'lodash/set';\nimport { useChoices, OptionText, UseChoicesOptions } from './useChoices';\nimport { useTranslate } from '../i18n';\n\n/*\n * Returns helper functions for suggestions handling.\n *\n * @param allowDuplicates A boolean indicating whether a suggestion can be added several times\n * @param choices An array of available choices\n * @param limitChoicesToValue A boolean indicating whether the initial suggestions should be limited to the currently selected one(s)\n * @param matchSuggestion Optional unless `optionText` is a React element. Function which check whether a choice matches a filter. Must return a boolean.\n * @param optionText Either a string defining the property to use to get the choice text, a function or a React element\n * @param optionValue The property to use to get the choice value\n * @param selectedItem The currently selected item. Maybe an array of selected items\n * @param suggestionLimit The maximum number of suggestions returned\n * @param translateChoice A boolean indicating whether to option text should be translated\n *\n * @returns An object with helper functions:\n * - getChoiceText: Returns the choice text or a React element\n * - getChoiceValue: Returns the choice value\n * - getSuggestions: A function taking a filter value (string) and returning the matching suggestions\n */\nexport const useSuggestions = ({\n    allowCreate,\n    choices,\n    createText = 'ra.action.create',\n    createValue = '@@create',\n    limitChoicesToValue,\n    matchSuggestion,\n    optionText,\n    optionValue,\n    selectedItem,\n    suggestionLimit = 0,\n    translateChoice,\n}: UseSuggestionsOptions) => {\n    const translate = useTranslate();\n    const { getChoiceText, getChoiceValue } = useChoices({\n        optionText,\n        optionValue,\n        translateChoice,\n    });\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const getSuggestions = useCallback(\n        getSuggestionsFactory({\n            allowCreate,\n            choices,\n            createText,\n            createValue,\n            getChoiceText,\n            getChoiceValue,\n            limitChoicesToValue,\n            matchSuggestion,\n            optionText,\n            optionValue,\n            selectedItem,\n            suggestionLimit,\n        }),\n        [\n            allowCreate,\n            choices,\n            createText,\n            createValue,\n            getChoiceText,\n            getChoiceValue,\n            limitChoicesToValue,\n            matchSuggestion,\n            optionText,\n            optionValue,\n            selectedItem,\n            suggestionLimit,\n            translate,\n        ]\n    );\n\n    return {\n        getChoiceText,\n        getChoiceValue,\n        getSuggestions,\n    };\n};\n\nconst escapeRegExp = value =>\n    value ? value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') : ''; // $& means the whole matched string\n\nexport interface UseSuggestionsOptions extends UseChoicesOptions {\n    allowCreate?: boolean;\n    allowDuplicates?: boolean;\n    choices: any[];\n    createText?: string;\n    createValue?: any;\n    limitChoicesToValue?: boolean;\n    matchSuggestion?: (\n        filter: string,\n        suggestion: any,\n        exact?: boolean\n    ) => boolean;\n    suggestionLimit?: number;\n    selectedItem?: any | any[];\n}\n\n/**\n * Default matcher implementation which check whether the suggestion text matches the filter.\n */\nconst defaultMatchSuggestion = getChoiceText => (\n    filter,\n    suggestion,\n    exact = false\n) => {\n    const suggestionText = getChoiceText(suggestion);\n\n    const isReactElement = isValidElement(suggestionText);\n    const regex = escapeRegExp(filter);\n\n    return isReactElement\n        ? false\n        : suggestionText &&\n              !!suggestionText.match(\n                  // We must escape any RegExp reserved characters to avoid errors\n                  // For example, the filter might contain * which must be escaped as \\*\n                  new RegExp(exact ? `^${regex}$` : regex, 'i')\n              );\n};\n\n/**\n * Get the suggestions to display after applying a fuzzy search on the available choices\n *\n * @example\n *\n * getSuggestions({\n *   choices: [{ id: 1, name: 'admin' }, { id: 2, name: 'publisher' }],\n *   optionText: 'name',\n *   optionValue: 'id',\n *   getSuggestionText: choice => choice[optionText],\n * })('pub')\n *\n * // Will return [{ id: 2, name: 'publisher' }]\n * getSuggestions({\n *   choices: [{ id: 1, name: 'admin' }, { id: 2, name: 'publisher' }],\n *   optionText: 'name',\n *   optionValue: 'id',\n *   getSuggestionText: choice => choice[optionText],\n * })('pub')\n *\n * // Will return [{ id: 2, name: 'publisher' }]\n */\nexport const getSuggestionsFactory = ({\n    allowCreate = false,\n    choices = [],\n    createText = 'ra.action.create',\n    createValue = '@@create',\n    optionText = 'name',\n    optionValue = 'id',\n    getChoiceText,\n    getChoiceValue,\n    limitChoicesToValue = false,\n    matchSuggestion = defaultMatchSuggestion(getChoiceText),\n    selectedItem,\n    suggestionLimit = 0,\n}: UseSuggestionsOptions & {\n    getChoiceText: (choice: any) => string | ReactElement;\n    getChoiceValue: (choice: any) => string;\n}) => filter => {\n    let suggestions: any[] = [];\n    // if an item is selected and matches the filter\n    if (\n        selectedItem &&\n        !Array.isArray(selectedItem) &&\n        matchSuggestion(filter, selectedItem)\n    ) {\n        if (limitChoicesToValue) {\n            // display only the selected item\n            suggestions = choices.filter(\n                choice =>\n                    getChoiceValue(choice) === getChoiceValue(selectedItem)\n            );\n        } else {\n            suggestions = [...choices];\n        }\n    } else {\n        suggestions = choices.filter(\n            choice =>\n                matchSuggestion(filter, choice) ||\n                (selectedItem != null &&\n                    (!Array.isArray(selectedItem)\n                        ? getChoiceValue(choice) ===\n                          getChoiceValue(selectedItem)\n                        : selectedItem.some(\n                              selected =>\n                                  getChoiceValue(choice) ===\n                                  getChoiceValue(selected)\n                          )))\n        );\n    }\n\n    suggestions = limitSuggestions(suggestions, suggestionLimit);\n\n    const hasExactMatch = suggestions.some(suggestion =>\n        matchSuggestion(filter, suggestion, true)\n    );\n\n    if (allowCreate) {\n        const filterIsSelectedItem =\n            // If the selectedItem is an array (for example AutocompleteArrayInput)\n            // we shouldn't try to match\n            !!selectedItem && !Array.isArray(selectedItem)\n                ? matchSuggestion(filter, selectedItem, true)\n                : false;\n        if (!hasExactMatch && !filterIsSelectedItem) {\n            suggestions.push(\n                getSuggestion({\n                    optionText,\n                    optionValue,\n                    text: createText,\n                    value: createValue,\n                })\n            );\n        }\n    }\n\n    // Only keep unique items. Necessary because we might have fetched\n    // the currently selected choice in addition of the possible choices\n    // that may also contain it\n    const result = suggestions.filter(\n        (suggestion, index) => suggestions.indexOf(suggestion) === index\n    );\n    return result;\n};\n\n/**\n * @example\n *\n * limitSuggestions(\n *  [{ id: 1, name: 'foo'}, { id: 2, name: 'bar' }],\n *  1\n * );\n *\n * // Will return [{ id: 1, name: 'foo' }]\n *\n * @param suggestions List of suggestions\n * @param limit\n */\nconst limitSuggestions = (suggestions: any[], limit: any = 0) =>\n    Number.isInteger(limit) && limit > 0\n        ? suggestions.slice(0, limit)\n        : suggestions;\n\n/**\n * addSuggestion(\n *  [{ id: 1, name: 'foo'}, { id: 2, name: 'bar' }],\n * );\n *\n * // Will return [{ id: null, name: '' }, { id: 1, name: 'foo' }, { id: 2, name: 'bar' }]\n *\n * @param suggestions List of suggestions\n * @param options\n * @param options.optionText\n */\nconst getSuggestion = ({\n    optionText = 'name',\n    optionValue = 'id',\n    text = '',\n    value = null,\n}: {\n    optionText: OptionText;\n    optionValue: string;\n    text: string;\n    value: any;\n}) => {\n    const suggestion = {};\n    set(suggestion, optionValue, value);\n    if (typeof optionText === 'string') {\n        set(suggestion, optionText, text);\n    }\n\n    return suggestion;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}