{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { useQuery, useQueryClient, hashQueryKey } from 'react-query';\nimport { useDataProvider } from './useDataProvider';\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, refetch }\n * - success: { data: [data from store], isLoading: false, refetch }\n * - error: { error: [error from response], isLoading: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getMany parameters { ids, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.ids The ids to get, e.g. [123, 456, 789]\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, error, isLoading, refetch }.\n *\n * @example\n *\n * import { useGetMany } from 'react-admin';\n *\n * const PostTags = ({ post }) => {\n *     const { data, isLoading, error } = useGetMany(\n *         'tags',\n *         { ids: post.tags },\n *     );\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <ul>{data.map(tag =>\n *         <li key={tag.id}>{tag.name}</li>\n *     )}</ul>;\n * };\n */\nexport var useGetMany = function (resource, params, options) {\n  if (params === void 0) {\n    params = {};\n  }\n  var ids = params.ids,\n    meta = params.meta;\n  var dataProvider = useDataProvider();\n  var queryClient = useQueryClient();\n  var queryCache = queryClient.getQueryCache();\n  return useQuery([resource, 'getMany', {\n    ids: !ids || ids.length === 0 ? [] : ids.map(function (id) {\n      return String(id);\n    }),\n    meta: meta\n  }], function () {\n    if (!ids || ids.length === 0) {\n      // no need to call the dataProvider\n      return Promise.resolve([]);\n    }\n    return dataProvider.getMany(resource, {\n      ids: ids,\n      meta: meta\n    }).then(function (_a) {\n      var data = _a.data;\n      return data;\n    });\n  }, __assign({\n    placeholderData: function () {\n      var records = !ids || ids.length === 0 ? [] : ids.map(function (id) {\n        var _a, _b;\n        var queryHash = hashQueryKey([resource, 'getOne', {\n          id: String(id),\n          meta: meta\n        }]);\n        return (_b = (_a = queryCache.get(queryHash)) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b.data;\n      });\n      if (records.some(function (record) {\n        return record === undefined;\n      })) {\n        return undefined;\n      } else {\n        return records;\n      }\n    },\n    onSuccess: function (data) {\n      // optimistically populate the getOne cache\n      data.forEach(function (record) {\n        queryClient.setQueryData([resource, 'getOne', {\n          id: String(record.id),\n          meta: meta\n        }], function (oldRecord) {\n          return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;\n        });\n      });\n    },\n    retry: false\n  }, options));\n};","map":{"version":3,"names":["useQuery","useQueryClient","hashQueryKey","useDataProvider","useGetMany","resource","params","options","ids","meta","dataProvider","queryClient","queryCache","getQueryCache","length","map","id","String","Promise","resolve","getMany","then","_a","data","__assign","placeholderData","records","queryHash","_b","get","state","some","record","undefined","onSuccess","forEach","setQueryData","oldRecord","retry"],"sources":["/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/ra-core/src/dataProvider/useGetMany.ts"],"sourcesContent":["import {\n    useQuery,\n    UseQueryOptions,\n    UseQueryResult,\n    useQueryClient,\n    hashQueryKey,\n} from 'react-query';\n\nimport { RaRecord, GetManyParams } from '../types';\nimport { useDataProvider } from './useDataProvider';\n\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, refetch }\n * - success: { data: [data from store], isLoading: false, refetch }\n * - error: { error: [error from response], isLoading: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getMany parameters { ids, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.ids The ids to get, e.g. [123, 456, 789]\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, error, isLoading, refetch }.\n *\n * @example\n *\n * import { useGetMany } from 'react-admin';\n *\n * const PostTags = ({ post }) => {\n *     const { data, isLoading, error } = useGetMany(\n *         'tags',\n *         { ids: post.tags },\n *     );\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <ul>{data.map(tag =>\n *         <li key={tag.id}>{tag.name}</li>\n *     )}</ul>;\n * };\n */\nexport const useGetMany = <RecordType extends RaRecord = any>(\n    resource: string,\n    params: Partial<GetManyParams> = {},\n    options?: UseQueryOptions<RecordType[], Error>\n): UseGetManyHookValue<RecordType> => {\n    const { ids, meta } = params;\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const queryCache = queryClient.getQueryCache();\n\n    return useQuery<RecordType[], Error, RecordType[]>(\n        [\n            resource,\n            'getMany',\n            {\n                ids: !ids || ids.length === 0 ? [] : ids.map(id => String(id)),\n                meta,\n            },\n        ],\n        () => {\n            if (!ids || ids.length === 0) {\n                // no need to call the dataProvider\n                return Promise.resolve([]);\n            }\n            return dataProvider\n                .getMany<RecordType>(resource, { ids, meta })\n                .then(({ data }) => data);\n        },\n        {\n            placeholderData: () => {\n                const records =\n                    !ids || ids.length === 0\n                        ? []\n                        : ids.map(id => {\n                              const queryHash = hashQueryKey([\n                                  resource,\n                                  'getOne',\n                                  { id: String(id), meta },\n                              ]);\n                              return queryCache.get<RecordType>(queryHash)\n                                  ?.state?.data;\n                          });\n                if (records.some(record => record === undefined)) {\n                    return undefined;\n                } else {\n                    return records as RecordType[];\n                }\n            },\n            onSuccess: data => {\n                // optimistically populate the getOne cache\n                data.forEach(record => {\n                    queryClient.setQueryData(\n                        [resource, 'getOne', { id: String(record.id), meta }],\n                        oldRecord => oldRecord ?? record\n                    );\n                });\n            },\n            retry: false,\n            ...options,\n        }\n    );\n};\n\nexport type UseGetManyHookValue<\n    RecordType extends RaRecord = any\n> = UseQueryResult<RecordType[], Error>;\n"],"mappings":";;;;;;;;;;AAAA,SACIA,QAAQ,EAGRC,cAAc,EACdC,YAAY,QACT,aAAa;AAGpB,SAASC,eAAe,QAAQ,mBAAmB;AAEnD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwCA,OAAO,IAAMC,UAAU,GAAG,SAAAA,CACtBC,QAAgB,EAChBC,MAAmC,EACnCC,OAA8C;EAD9C,IAAAD,MAAA;IAAAA,MAAA,KAAmC;EAAA;EAG3B,IAAAE,GAAG,GAAWF,MAAM,CAAAE,GAAjB;IAAEC,IAAI,GAAKH,MAAM,CAAAG,IAAX;EACjB,IAAMC,YAAY,GAAGP,eAAe,EAAE;EACtC,IAAMQ,WAAW,GAAGV,cAAc,EAAE;EACpC,IAAMW,UAAU,GAAGD,WAAW,CAACE,aAAa,EAAE;EAE9C,OAAOb,QAAQ,CACX,CACIK,QAAQ,EACR,SAAS,EACT;IACIG,GAAG,EAAE,CAACA,GAAG,IAAIA,GAAG,CAACM,MAAM,KAAK,CAAC,GAAG,EAAE,GAAGN,GAAG,CAACO,GAAG,CAAC,UAAAC,EAAE;MAAI,OAAAC,MAAM,CAACD,EAAE,CAAC;IAAV,CAAU,CAAC;IAC9DP,IAAI,EAAAA;GACP,CACJ,EACD;IACI,IAAI,CAACD,GAAG,IAAIA,GAAG,CAACM,MAAM,KAAK,CAAC,EAAE;MAC1B;MACA,OAAOI,OAAO,CAACC,OAAO,CAAC,EAAE,CAAC;;IAE9B,OAAOT,YAAY,CACdU,OAAO,CAAaf,QAAQ,EAAE;MAAEG,GAAG,EAAAA,GAAA;MAAEC,IAAI,EAAAA;IAAA,CAAE,CAAC,CAC5CY,IAAI,CAAC,UAACC,EAAQ;UAANC,IAAI,GAAAD,EAAA,CAAAC,IAAA;MAAO,OAAAA,IAAI;IAAJ,CAAI,CAAC;EACjC,CAAC,EAAAC,QAAA;IAEGC,eAAe,EAAE,SAAAA,CAAA;MACb,IAAMC,OAAO,GACT,CAAClB,GAAG,IAAIA,GAAG,CAACM,MAAM,KAAK,CAAC,GAClB,EAAE,GACFN,GAAG,CAACO,GAAG,CAAC,UAAAC,EAAE;;QACN,IAAMW,SAAS,GAAGzB,YAAY,CAAC,CAC3BG,QAAQ,EACR,QAAQ,EACR;UAAEW,EAAE,EAAEC,MAAM,CAACD,EAAE,CAAC;UAAEP,IAAI,EAAAA;QAAA,CAAE,CAC3B,CAAC;QACF,OAAO,CAAAmB,EAAA,IAAAN,EAAA,GAAAV,UAAU,CAACiB,GAAG,CAAaF,SAAS,CAAC,cAAAL,EAAA,uBAAAA,EAAA,CACtCQ,KAAK,cAAAF,EAAA,uBAAAA,EAAA,CAAEL,IAAI;MACrB,CAAC,CAAC;MACZ,IAAIG,OAAO,CAACK,IAAI,CAAC,UAAAC,MAAM;QAAI,OAAAA,MAAM,KAAKC,SAAS;MAApB,CAAoB,CAAC,EAAE;QAC9C,OAAOA,SAAS;OACnB,MAAM;QACH,OAAOP,OAAuB;;IAEtC,CAAC;IACDQ,SAAS,EAAE,SAAAA,CAAAX,IAAI;MACX;MACAA,IAAI,CAACY,OAAO,CAAC,UAAAH,MAAM;QACfrB,WAAW,CAACyB,YAAY,CACpB,CAAC/B,QAAQ,EAAE,QAAQ,EAAE;UAAEW,EAAE,EAAEC,MAAM,CAACe,MAAM,CAAChB,EAAE,CAAC;UAAEP,IAAI,EAAAA;QAAA,CAAE,CAAC,EACrD,UAAA4B,SAAS;UAAI,OAAAA,SAAS,aAATA,SAAS,cAATA,SAAS,GAAIL,MAAM;QAAnB,CAAmB,CACnC;MACL,CAAC,CAAC;IACN,CAAC;IACDM,KAAK,EAAE;EAAK,GACT/B,OAAO,EAEjB;AACL,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}