{"ast":null,"code":"import e from \"axios\";\nimport t from \"js-cookie\";\nconst r = {\n  user: {},\n  tokens: {},\n  mode: \"live\"\n};\nfunction n(e) {\n  try {\n    const t = e.split(\".\")[1].replace(\"-\", \"+\").replace(\"_\", \"/\");\n    return JSON.parse(atob(t));\n  } catch (e) {\n    console.error(\"Problem decoding JWT payload\", e);\n  }\n}\nfunction o(e) {\n  try {\n    if (!e) return !1;\n    const t = n(e);\n    return new Date(1e3 * t.exp) > new Date();\n  } catch (e) {\n    return !1;\n  }\n}\nfunction i(e) {\n  var t, r;\n  if (e) {\n    if (\"string\" == typeof e) throw new Error(e);\n    if (null != e && null != (t = e.response) && null != (r = t.data) && r.message) throw new Error(e.response.data.message);\n    throw e;\n  }\n}\nfunction s() {\n  return \"undefined\" != typeof window;\n}\nconst a = r.user;\nfunction c(e) {\n  return e.replace(/([^:]\\/)\\/+/g, \"$1\");\n}\nconst u = function (t, n, o) {\n    try {\n      const i = c(`${r.baseUrl}${t}`);\n      return Promise.resolve(e.put(i, n, o));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  d = function (t, n, o) {\n    try {\n      const i = c(`${r.baseUrl}${t}`);\n      return Promise.resolve(e.post(i, n, o));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  h = function (t, n) {\n    try {\n      const o = c(`${r.baseUrl}${t}`);\n      return Promise.resolve(e.get(o, n));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\nfunction l(e, n, o) {\n  const i = `${o}.${r.tenantId}`;\n  n = n || {\n    secure: \"live\" === r.mode,\n    sameSite: \"Lax\"\n  }, \"refresh\" === o && (n.sameSite = \"Strict\"), t.set(i, e, n);\n}\nfunction f(e) {\n  let r, n;\n  try {\n    const e = window.location.pathname,\n      t = window.location.hostname,\n      o = t.split(\".\").slice(-2).join(\".\");\n    r = [void 0, e, \"/\"], n = [void 0, t, `.${t}`, o, `.${o}`];\n  } catch (e) {\n    r = [void 0, \"/\"], n = [void 0];\n  }\n  r.map(r => {\n    n.map(n => {\n      const o = {};\n      n && (o.domain = n), r && (o.path = r), t.remove(e, o);\n    });\n  });\n}\nfunction m() {\n  f(r.tokens.accessTokenName), f(r.tokens.idTokenName), f(r.tokens.refreshTokenName), r.tokens.accessToken = void 0, r.tokens.idToken = void 0, r.tokens.refreshToken = void 0, function () {\n    for (const e in r.user) \"function\" != typeof r.user[e] && delete r.user[e];\n  }();\n}\nfunction p(e) {\n  l(e.access.value, e.access.cookieOptions, \"access\"), l(e.id.value, e.id.cookieOptions, \"id\"), e.refresh && e.refresh.value && l(e.refresh.value, e.refresh.cookieOptions, \"refresh\"), P();\n}\nfunction w(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n  return r && r.then ? r.then(void 0, t) : r;\n}\nconst v = function (_ref) {\n    let {} = _ref;\n    return Promise.resolve();\n  },\n  k = function () {\n    try {\n      const e = w(function () {\n        return Promise.resolve(function () {\n          try {\n            const e = t.get(r.tokens.refreshTokenName);\n            return Promise.resolve(w(function () {\n              return Promise.resolve(h(\"/auth/refresh\", {\n                headers: {\n                  authorization: `Bearer ${e}`\n                }\n              })).then(function (_ref2) {\n                let {\n                  data: e,\n                  status: t\n                } = _ref2;\n                if (200 !== t) throw new Error(e.message || \"Problem with request\");\n                if (e.tokens) return p(e.tokens), e;\n                throw new Error(\"Problem setting cookies\");\n              });\n            }, function (e) {\n              i(e);\n            }));\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        }()).then(function () {});\n      }, function (e) {\n        console.warn(`Refresh failed: ${e.message}`);\n      });\n      return Promise.resolve(e && e.then ? e.then(function () {}) : void 0);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\nfunction P() {\n  [\"access\", \"id\", \"refresh\"].map(e => {\n    try {\n      const o = t.get(r.tokens[`${e}TokenName`]);\n      r.tokens[`${e}Token`] = o, \"id\" === e && o && function () {\n        if (!r.tokens.idToken) return console.warn(\"Cannot define user: missing ID token\");\n        r.user = r.user || {};\n        const e = n(r.tokens.idToken),\n          t = [\"email\", \"phoneNumber\", \"username\", \"name\", \"image\", \"data\", \"confirmedAt\", \"createdAt\", \"updatedAt\", \"mode\", \"userId\", \"userUuid\", \"tenantId\", \"isConfirmed\"];\n        for (const n of t) {\n          if (\"update\" === n) return;\n          r.user[n] = e[n];\n        }\n      }();\n    } catch (t) {\n      console.warn(`Problem setting ${e} token.`);\n    }\n  });\n}\nfunction g() {\n  return o(r.tokens.accessToken);\n}\nr.tokens = r.tokens || {}, r.tokens.refresh = k;\nconst y = r.tokens,\n  T = {\n    firstFactors: [],\n    secondFactors: [],\n    firstFactorToken: null\n  };\nfunction I() {\n  return !!T.firstFactorToken;\n}\nfunction b(e) {\n  e.isMfaRequired ? (T.secondFactors = e.authentication.secondFactors, T.firstFactorToken = e.firstFactorToken) : \"OK\" === e.message && $();\n}\nfunction E() {\n  return T.firstFactorToken ? {\n    authorization: `Bearer ${T.firstFactorToken}`\n  } : {};\n}\nfunction $() {\n  T.secondFactors = [], T.firstFactorToken = null;\n}\nconst C = function () {\n    try {\n      return Promise.resolve(j()).then(function (e) {\n        return {\n          isLoggedIn: e,\n          needsSecondFactor: I(),\n          firstFactors: T.firstFactors,\n          secondFactors: T.secondFactors,\n          resetMfaState: $\n        };\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  j = function () {\n    return Promise.resolve(function (e, t) {\n      try {\n        var n = !!g() || !!o(r.tokens.refreshToken) && Promise.resolve(k()).then(function () {\n          return g();\n        });\n      } catch (e) {\n        return !1;\n      }\n      return n && n.then ? n.then(void 0, function () {\n        return !1;\n      }) : n;\n    }());\n  },\n  U = {\n    codeChallenge: \"\",\n    get usePkce() {\n      return !!U.codeChallenge;\n    }\n  };\nfunction F() {\n  s() && (window.localStorage.removeItem(\"uf_pkce_code_challenge\"), window.localStorage.removeItem(\"uf_pkce_code_challenge_expiresAt\"));\n}\nfunction _() {\n  if (!s()) return;\n  const e = O(\"code_challenge\");\n  if (e) return U.codeChallenge = e, function (e) {\n    if (!s()) return;\n    if (!e) return F();\n    U.codeChallenge = e;\n    const t = Date.now() + 3e5;\n    try {\n      window.localStorage.setItem(\"uf_pkce_code_challenge\", e), window.localStorage.setItem(\"uf_pkce_code_challenge_expiresAt\", t);\n    } catch (e) {}\n  }(e), !0;\n  const t = function () {\n    if (!s()) return;\n    const e = window.localStorage.getItem(\"uf_pkce_code_challenge\");\n    if (e) {\n      const t = window.localStorage.getItem(\"uf_pkce_code_challenge_expiresAt\");\n      if (t && parseInt(t, 10) > Date.now()) return e;\n    }\n  }();\n  return t ? (U.codeChallenge = t, !0) : (F(), !1);\n}\nfunction N() {\n  return U.usePkce ? {\n    code_challenge: U.codeChallenge\n  } : {};\n}\nfunction z(e, t) {\n  if (!e || !t) return;\n  U.usePkce || console.warn(\"Redirecting with a PKCE authorization code, but no PKCE challenge code is present in the client. This is unexpected.\");\n  const r = new URL(e);\n  r.searchParams.set(\"authorization_code\", t), F(), window.location.assign(r.href);\n}\nfunction O(e) {\n  if (\"object\" == typeof window && \"object\" == typeof window.location && window.location.href && !(window.location.href.indexOf(`${e}=`) < 0)) return decodeURIComponent(window.location.href.split(`${e}=`)[1].split(\"&\")[0]);\n}\nconst S = _ref3 => {\n  let {\n    redirect: e,\n    data: t\n  } = _ref3;\n  !1 !== e && x(e || O(\"redirect\") || t.redirectTo || \"/\");\n};\nfunction x(e) {\n  if (!e || \"object\" != typeof document || \"object\" != typeof window) return;\n  try {\n    document && window;\n  } catch (e) {\n    return;\n  }\n  const t = document.createElement(\"a\");\n  t.href = e, t.pathname !== window.location.pathname && window.location.assign(`${t.pathname}${t.hash}${t.search}`);\n}\nfunction R(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n  return r && r.then ? r.then(void 0, t) : r;\n}\nconst L = function (_ref4) {\n    let {\n      password: e,\n      existingPassword: t\n    } = _ref4;\n    try {\n      return Promise.resolve(R(function () {\n        if (!r.tokens.accessToken) throw new Error('updatePassword({ method: \"jwt\" }) was called without a JWT access token.');\n        return Promise.resolve(u(\"/auth/basic\", {\n          tenantId: r.tenantId,\n          password: e,\n          existingPassword: t\n        }, {\n          headers: {\n            Authorization: `Bearer ${r.tokens.accessToken}`\n          }\n        })).then(function (_ref5) {\n          let {\n            data: e\n          } = _ref5;\n          return e;\n        });\n      }, function (e) {\n        i(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  A = function (_ref6) {\n    let {\n      uuid: e,\n      token: t,\n      password: n,\n      redirect: o\n    } = _ref6;\n    try {\n      return Promise.resolve(R(function () {\n        if (t = t || O(\"token\"), e = e || O(\"uuid\"), !t || !e) throw new Error(\"Missing token or uuid\");\n        return Promise.resolve(u(\"/auth/reset\", {\n          tenantId: r.tenantId,\n          uuid: e,\n          token: t,\n          password: n\n        })).then(function (_ref7) {\n          let {\n            data: e\n          } = _ref7;\n          if (e.tokens) return p(e.tokens), S({\n            redirect: o,\n            data: e\n          }), e;\n          throw new Error(\"There was a problem resetting your password. Please try again.\");\n        });\n      }, function (e) {\n        i(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  M = function (_ref8) {\n    let {\n      method: e,\n      password: t,\n      existingPassword: n,\n      uuid: o,\n      token: i,\n      redirect: s\n    } = _ref8;\n    try {\n      switch (e) {\n        case \"link\":\n          return A({\n            uuid: o,\n            token: i,\n            password: t,\n            redirect: s\n          });\n        case \"jwt\":\n          return L({\n            password: t,\n            existingPassword: n\n          });\n        default:\n          if (i = i || O(\"token\"), (o = o || O(\"uuid\")) && i) return A({\n            uuid: o,\n            token: i,\n            password: t,\n            redirect: s\n          });\n          if (r.tokens.accessToken) return L({\n            password: t,\n            existingPassword: n\n          });\n          throw new Error(\"updatePassword() was called without link credentials (token & uuid) or a JWT access token.\");\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  q = M;\nfunction B(_ref9) {\n  let {\n    provider: e,\n    redirect: t\n  } = _ref9;\n  if (!e) throw new Error(\"Missing provider\");\n  const n = function (_ref10) {\n    let {\n      provider: e,\n      redirect: t\n    } = _ref10;\n    if (!e) throw new Error(\"Missing provider\");\n    if (!r.tenantId) throw new Error(\"Missing tenantId\");\n    let n = `${r.baseUrl}auth/${e}/login?tenant_id=${r.tenantId}&origin=${window.location.origin}`,\n      o = t || O(\"redirect\");\n    return !1 === t && (o = \"object\" == typeof document && document.location.pathname), o && (n += `&redirect=${encodeURIComponent(o)}`), n;\n  }({\n    provider: e,\n    redirect: t\n  });\n  window.location.assign(n);\n}\nfunction D(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n  return r && r.then ? r.then(void 0, t) : r;\n}\nconst K = function (_ref11) {\n  let {\n    email: e,\n    name: t,\n    username: n,\n    userData: o,\n    options: s\n  } = _ref11;\n  try {\n    return Promise.resolve(D(function () {\n      return Promise.resolve(d(\"/auth/link\", {\n        email: e,\n        name: t,\n        username: n,\n        data: o,\n        options: s,\n        tenantId: r.tenantId\n      })).then(function (_ref12) {\n        let {\n          data: e\n        } = _ref12;\n        return e;\n      });\n    }, function (e) {\n      i(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nfunction J(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n  return r && r.then ? r.then(void 0, t) : r;\n}\nfunction W(_ref13) {\n  let {\n    channel: e,\n    phoneNumber: t,\n    email: r\n  } = _ref13;\n  if (\"sms\" !== e && \"email\" !== e) throw new Error(\"Invalid channel\");\n  if (\"sms\" === e && !t) throw new Error('SMS verification code requires \"phoneNumber\"');\n  if (\"email\" === e && !r) throw new Error('Email verification code requires \"email\"');\n}\nconst V = function (_ref14) {\n  let {\n    channel: e = \"sms\",\n    phoneNumber: t,\n    email: n,\n    name: o,\n    username: s,\n    data: a\n  } = _ref14;\n  try {\n    return Promise.resolve(J(function () {\n      return W({\n        channel: e,\n        phoneNumber: t,\n        email: n\n      }), Promise.resolve(d(\"/auth/code\", {\n        channel: e,\n        email: n,\n        phoneNumber: t,\n        name: o,\n        username: s,\n        data: a,\n        tenantId: r.tenantId\n      }, {\n        headers: E()\n      })).then(function (_ref15) {\n        let {\n          data: e\n        } = _ref15;\n        return e;\n      });\n    }, function (e) {\n      i(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nfunction G(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n  return r && r.then ? r.then(void 0, t) : r;\n}\nfunction H(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n  return r && r.then ? r.then(void 0, t) : r;\n}\nconst Q = /((^127\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.))\\d{1,3}\\.\\d{1,3}/g,\n  X = function () {\n    try {\n      return Promise.resolve(function (e, t) {\n        try {\n          var n = Promise.resolve(h(`/tenants/${r.tenantId}/mode`)).then(function (_ref16) {\n            let {\n              data: e\n            } = _ref16;\n            var t;\n            return Y.value = e.mode || \"test\", Y.reason = ee(Y.value), r.mode = Y.value, t = e.authentication, r.tenantId ? t && \"object\" == typeof t && Array.isArray(t.firstFactors) ? T.firstFactors = t.firstFactors : console.warn(\"setFirstFactors: invalid factors passed.\") : console.warn(\"setFirstFactors: tried to set factors without a tenantId set.\"), e;\n          });\n        } catch (e) {\n          return t();\n        }\n        return n && n.then ? n.then(void 0, t) : n;\n      }(0, function () {\n        Y.value = \"test\", r.mode = Y.value;\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  Y = {\n    value: \"live\",\n    reason: void 0,\n    setMode: X\n  };\nfunction Z() {\n  const e = function (e) {\n    try {\n      const e = window.location.hostname;\n      return !(!e.match(/localhost/g) && !e.match(Q));\n    } catch (e) {\n      return !0;\n    }\n  }() || !function () {\n    try {\n      return \"https:\" === window.location.protocol;\n    } catch (e) {\n      return !1;\n    }\n  }() ? \"test\" : \"live\";\n  Y.value = e, Y.reason = ee(e), r.mode = e;\n}\nfunction ee(e) {\n  try {\n    return \"live\" === e ? \"domain\" : \"http:\" === window.location.protocol ? \"http\" : \"https:\" !== window.location.protocol ? \"protocol\" : \"domain\";\n  } catch (e) {}\n}\nZ(), r.user.update = function (e) {\n  try {\n    return !e || Object.keys(e).length < 1 ? Promise.resolve(console.warn(\"Missing user properties to update\")) : Promise.resolve(u(\"/self\", e, {\n      headers: {\n        authorization: `Bearer ${r.tokens.accessToken}`\n      }\n    })).then(function () {\n      return Promise.resolve(k()).then(function () {\n        return r.user;\n      });\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}, r.user.hasRole = function (e) {\n  let {\n    tenantId: t\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  try {\n    if (!r.tokens.accessToken || !r.tenantId) return !1;\n    const {\n      authorization: o\n    } = n(r.tokens.accessToken);\n    return !!o && !(!o[t = t || r.tenantId] || !o[t].roles) && o[t].roles.indexOf(e) > -1;\n  } catch (e) {\n    return !1;\n  }\n}, r.user.updatePassword = M, r.user.getTotp = function () {\n  try {\n    let e;\n    return Promise.resolve(G(function () {\n      function t(t) {\n        if (e) return t;\n        if (!r.tokens.accessToken) throw new Error(\"getTotp() was called without a JWT access token.\");\n        return Promise.resolve(h(\"/auth/totp\", {\n          headers: {\n            Authorization: `Bearer ${r.tokens.accessToken}`\n          }\n        })).then(function (_ref17) {\n          let {\n            data: e\n          } = _ref17;\n          return e;\n        });\n      }\n      const n = function () {\n        if (I()) return Promise.resolve(h(\"/auth/totp\", {\n          headers: E()\n        })).then(function (_ref18) {\n          let {\n            data: t\n          } = _ref18;\n          return e = 1, t;\n        });\n      }();\n      return n && n.then ? n.then(t) : t(n);\n    }, function (e) {\n      i(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nlet te = [],\n  re = !1;\nvar ne = {\n  addInitCallback: function (e) {\n    e && \"function\" == typeof e && te.push(e);\n  },\n  init: function (t) {\n    let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!t) return console.warn(\"Userfront initialized without tenantId\");\n    if (r.tenantId = t, r.baseUrl = n.baseUrl || \"https://api.userfront.com/v0/\", r.baseUrl.endsWith(\"/\") || (r.baseUrl += \"/\"), n.domain) {\n      r.domain = n.domain;\n      const t = `https://${r.domain}`;\n      e.defaults.headers.common[\"x-application-id\"] = t, e.defaults.headers.common[\"x-origin\"] = t;\n    }\n    r.tokens = r.tokens || {}, r.tokens.accessTokenName = `access.${r.tenantId}`, r.tokens.idTokenName = `id.${r.tenantId}`, r.tokens.refreshTokenName = `refresh.${r.tenantId}`, P(), Z(), $(), T.firstFactors = [];\n    try {\n      te.length > 0 && te.forEach(e => {\n        e && \"function\" == typeof e && e({\n          tenantId: t\n        });\n      }), te = [];\n    } catch (e) {}\n  },\n  registerUrlChangedEventListener: function () {\n    if (!re) {\n      re = !0;\n      try {\n        history.pushState = (e = history.pushState, function () {\n          var t = e.apply(this, arguments);\n          return window.dispatchEvent(new Event(\"pushstate\")), window.dispatchEvent(new Event(\"urlchanged\")), t;\n        }), history.replaceState = (e => function () {\n          var t = e.apply(this, arguments);\n          return window.dispatchEvent(new Event(\"replacestate\")), window.dispatchEvent(new Event(\"urlchanged\")), t;\n        })(history.replaceState), window.addEventListener(\"popstate\", () => {\n          window.dispatchEvent(new Event(\"urlchanged\"));\n        });\n      } catch (e) {}\n      var e;\n    }\n  },\n  logout: function () {\n    let {\n      method: e,\n      redirect: t\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      if (\"saml\" === e) return function () {\n        try {\n          if (!r.tokens.accessToken) throw new Error(\"Please log in to authorize your logout request.\");\n          const e = H(function () {\n            return Promise.resolve(h(\"/auth/saml/idp/token\", {\n              headers: {\n                authorization: `Bearer ${r.tokens.accessToken}`\n              }\n            })).then(function (_ref19) {\n              let {\n                data: e\n              } = _ref19;\n              window.location.assign(`${r.baseUrl}auth/saml/idp/logout?tenant_id=${r.tenantId}&token=${e.token}&uuid=${r.user.userUuid}`);\n            });\n          }, function (e) {\n            i(e);\n          });\n          return Promise.resolve(e && e.then ? e.then(function () {}) : void 0);\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }();\n      if (!r.tokens.accessToken) return Promise.resolve(m());\n      const n = H(function () {\n        return Promise.resolve(h(\"/auth/logout\", {\n          headers: {\n            authorization: `Bearer ${r.tokens.accessToken}`\n          }\n        })).then(function (_ref20) {\n          let {\n            data: e\n          } = _ref20;\n          m(), S({\n            redirect: t,\n            data: e\n          });\n        });\n      }, function () {\n        m();\n      });\n      return Promise.resolve(n && n.then ? n.then(function () {}) : void 0);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  mode: Y,\n  setMode: X,\n  refresh: (e, t, r) => {\n    try {\n      console.warn(\"Userfront.refresh() is deprecated and will be removed. Please use Userfront.tokens.refresh() instead.\");\n    } catch (e) {}\n    return k();\n  },\n  login: function () {\n    let {\n      method: e,\n      userId: t,\n      userUuid: n,\n      email: o,\n      username: s,\n      emailOrUsername: a,\n      phoneNumber: c,\n      password: l,\n      token: f,\n      uuid: m,\n      totpCode: w,\n      backupCode: k,\n      channel: P,\n      verificationCode: g,\n      redirect: y,\n      options: T\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      if (!e) throw new Error('Userfront.login called without \"method\" property.');\n      switch (_(), e) {\n        case \"apple\":\n        case \"azure\":\n        case \"facebook\":\n        case \"github\":\n        case \"google\":\n        case \"linkedin\":\n          return Promise.resolve(B({\n            provider: e,\n            redirect: y\n          }));\n        case \"password\":\n          return Promise.resolve(function (_ref21) {\n            let {\n              email: e,\n              username: t,\n              emailOrUsername: n,\n              password: o,\n              redirect: s,\n              options: a\n            } = _ref21;\n            try {\n              return Promise.resolve(R(function () {\n                const i = {\n                  tenantId: r.tenantId,\n                  emailOrUsername: e || t || n,\n                  password: o\n                };\n                return a && a.noResetEmail && (i.options = {\n                  noResetEmail: !0\n                }), Promise.resolve(d(\"/auth/basic\", i, {\n                  headers: E(),\n                  params: N()\n                })).then(function (_ref22) {\n                  let {\n                    data: e\n                  } = _ref22;\n                  let t;\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorToken\")) return b(e), e;\n                    if (e.authorizationCode) {\n                      const t = s || e.redirectTo;\n                      if (t) return void z(t, e.authorizationCode);\n                    }\n                    throw new Error(\"Please try again.\");\n                  }\n                  const n = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return p(e.tokens), Promise.resolve(v(e)).then(function () {\n                      return S({\n                        redirect: s,\n                        data: e\n                      }), t = 1, e;\n                    });\n                  }();\n                  return n && n.then ? n.then(r) : r(n);\n                });\n              }, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            email: o,\n            username: s,\n            emailOrUsername: a,\n            password: l,\n            redirect: y,\n            options: T\n          }));\n        case \"passwordless\":\n          return Promise.resolve(K({\n            email: o\n          }));\n        case \"link\":\n          return Promise.resolve(function () {\n            let {\n              token: e,\n              uuid: t,\n              redirect: n\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            try {\n              return Promise.resolve(D(function () {\n                if (e = e || O(\"token\"), t = t || O(\"uuid\"), e && t) return Promise.resolve(u(\"/auth/link\", {\n                  token: e,\n                  uuid: t,\n                  tenantId: r.tenantId\n                }, {\n                  headers: E(),\n                  params: N()\n                })).then(function (_ref23) {\n                  let {\n                    data: e\n                  } = _ref23;\n                  let t;\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorToken\")) return b(e), e;\n                    if (e.authorizationCode) {\n                      const t = n || e.redirectTo;\n                      if (t) return void z(t, e.authorizationCode);\n                      throw new Error(\"Received a PKCE (mobile auth) response from the server, but no redirect was provided. Please set the redirect to the app that initiated the request.\");\n                    }\n                    throw new Error(\"Problem logging in.\");\n                  }\n                  const o = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return $(), p(e.tokens), Promise.resolve(v(e)).then(function () {\n                      return S({\n                        redirect: n,\n                        data: e\n                      }), t = 1, e;\n                    });\n                  }();\n                  return o && o.then ? o.then(r) : r(o);\n                });\n              }, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            token: f,\n            uuid: m,\n            redirect: y\n          }));\n        case \"totp\":\n          return Promise.resolve(function () {\n            let {\n              totpCode: e,\n              backupCode: t,\n              userId: n,\n              userUuid: o,\n              emailOrUsername: s,\n              email: a,\n              username: c,\n              phoneNumber: u,\n              redirect: h\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            try {\n              return Promise.resolve(G(function () {\n                return Promise.resolve(d(\"/auth/totp\", {\n                  totpCode: e,\n                  backupCode: t,\n                  userId: n,\n                  userUuid: o,\n                  emailOrUsername: s,\n                  email: a,\n                  username: c,\n                  phoneNumber: u,\n                  tenantId: r.tenantId\n                }, {\n                  headers: E(),\n                  params: N()\n                })).then(function (_ref24) {\n                  let {\n                    data: e\n                  } = _ref24;\n                  let t;\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorToken\")) return b(e), e;\n                    if (e.authorizationCode) {\n                      const t = h || e.redirectTo;\n                      if (t) return void z(t, e.authorizationCode);\n                      throw new Error(\"Received a PKCE (mobile auth) response from the server, but no redirect was provided. Please set the redirect to the app that initiated the request.\");\n                    }\n                    throw new Error(\"Problem logging in.\");\n                  }\n                  const n = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return $(), p(e.tokens), Promise.resolve(v(e)).then(function () {\n                      return S({\n                        redirect: h,\n                        data: e\n                      }), t = 1, e;\n                    });\n                  }();\n                  return n && n.then ? n.then(r) : r(n);\n                });\n              }, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            totpCode: w,\n            backupCode: k,\n            userId: t,\n            userUuid: n,\n            emailOrUsername: a,\n            email: o,\n            username: s,\n            phoneNumber: c,\n            redirect: y\n          }));\n        case \"verificationCode\":\n          return Promise.resolve(function () {\n            let {\n              channel: e,\n              verificationCode: t,\n              email: n,\n              phoneNumber: o,\n              redirect: s\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            try {\n              return Promise.resolve(J(function () {\n                return W({\n                  channel: e,\n                  phoneNumber: o,\n                  email: n\n                }), Promise.resolve(u(\"/auth/code\", {\n                  channel: e,\n                  verificationCode: t,\n                  email: n,\n                  phoneNumber: o,\n                  tenantId: r.tenantId\n                }, {\n                  headers: E(),\n                  params: N()\n                })).then(function (_ref25) {\n                  let {\n                    data: e\n                  } = _ref25;\n                  let t;\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorToken\")) return b(e), e;\n                    if (e.authorizationCode) {\n                      const t = s || e.redirectTo;\n                      if (t) return void z(t, e.authorizationCode);\n                      throw new Error(\"Received a PKCE (mobile auth) response from the server, but no redirect was provided. Please set the redirect to the app that initiated the request.\");\n                    }\n                    throw new Error(\"Problem logging in.\");\n                  }\n                  const n = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return $(), p(e.tokens), Promise.resolve(v(e)).then(function () {\n                      return S({\n                        redirect: s,\n                        data: e\n                      }), t = 1, e;\n                    });\n                  }();\n                  return n && n.then ? n.then(r) : r(n);\n                });\n              }, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            channel: P,\n            email: o,\n            phoneNumber: c,\n            verificationCode: g,\n            redirect: y\n          }));\n        case \"saml\":\n          return Promise.resolve(function () {\n            try {\n              return Promise.resolve(function (e, t) {\n                try {\n                  var n = r.tokens.accessToken ? Promise.resolve(h(\"/auth/saml/idp/token\", {\n                    headers: {\n                      authorization: `Bearer ${r.tokens.accessToken}`\n                    }\n                  })).then(function (_ref26) {\n                    let {\n                      data: e\n                    } = _ref26;\n                    window.location.assign(`${r.baseUrl}auth/saml/idp/login?tenant_id=${r.tenantId}&token=${e.token}&uuid=${r.user.userUuid}`);\n                  }) : console.warn(\"Cannot complete SAML login without access token\");\n                } catch (e) {\n                  return t(e);\n                }\n                return n && n.then ? n.then(void 0, t) : n;\n              }(0, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }());\n        default:\n          throw new Error('Userfront.login called with invalid \"method\" property.');\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  resetPassword: q,\n  updatePassword: M,\n  sendLoginLink: function (e) {\n    try {\n      return Promise.resolve(D(function () {\n        return Promise.resolve(d(\"/auth/link\", {\n          email: e,\n          tenantId: r.tenantId\n        })).then(function (_ref27) {\n          let {\n            data: e\n          } = _ref27;\n          return e;\n        });\n      }, function (e) {\n        i(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  sendResetLink: function (e) {\n    try {\n      return Promise.resolve(R(function () {\n        return Promise.resolve(d(\"/auth/reset/link\", {\n          email: e,\n          tenantId: r.tenantId\n        })).then(function (_ref28) {\n          let {\n            data: e\n          } = _ref28;\n          return e;\n        });\n      }, function (e) {\n        i(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  sendVerificationCode: V,\n  signup: function () {\n    let {\n      method: e,\n      email: t,\n      username: n,\n      phoneNumber: o,\n      name: s,\n      data: a,\n      password: c,\n      channel: u,\n      redirect: h\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      if (_(), !e) throw new Error('Userfront.signup called without \"method\" property.');\n      switch (e) {\n        case \"apple\":\n        case \"azure\":\n        case \"facebook\":\n        case \"github\":\n        case \"google\":\n        case \"linkedin\":\n          return Promise.resolve(B({\n            provider: e,\n            redirect: h\n          }));\n        case \"password\":\n          return Promise.resolve(function () {\n            let {\n              username: e,\n              name: t,\n              email: n,\n              password: o,\n              userData: s,\n              redirect: a\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            try {\n              return Promise.resolve(R(function () {\n                return Promise.resolve(d(\"/auth/create\", {\n                  tenantId: r.tenantId,\n                  username: e,\n                  name: t,\n                  email: n,\n                  password: o,\n                  data: s\n                }, {\n                  headers: E(),\n                  params: N()\n                })).then(function (_ref29) {\n                  let {\n                    data: e\n                  } = _ref29;\n                  return function () {\n                    if (e.tokens) return $(), p(e.tokens), Promise.resolve(v(e)).then(function () {\n                      return S({\n                        redirect: a,\n                        data: e\n                      }), e;\n                    });\n                    if (e.firstFactorToken) return b(e), e;\n                    if (!e.authorizationCode) throw new Error(\"Please try again.\");\n                    {\n                      const t = a || e.redirectTo;\n                      if (!t) throw new Error(\"Received a PKCE (mobile auth) response from the server, but no redirect was provided. Please set the redirect to the app that initiated the request.\");\n                      z(t, e.authorizationCode);\n                    }\n                  }();\n                });\n              }, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            username: n,\n            name: s,\n            email: t,\n            password: c,\n            userData: a,\n            redirect: h\n          }));\n        case \"passwordless\":\n          return Promise.resolve(K({\n            email: t,\n            name: s,\n            username: n,\n            userData: a\n          }));\n        case \"verificationCode\":\n          return Promise.resolve(V({\n            channel: u,\n            email: t,\n            phoneNumber: o,\n            name: s,\n            username: n,\n            data: a\n          }));\n        default:\n          throw new Error('Userfront.signup called with invalid \"method\" property.');\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  store: r,\n  tokens: y,\n  accessToken: function () {\n    return r.tokens.accessToken = t.get(r.tokens.accessTokenName), r.tokens.accessToken;\n  },\n  idToken: function () {\n    return r.tokens.idToken = t.get(r.tokens.idTokenName), r.tokens.idToken;\n  },\n  getSession: C,\n  redirectIfLoggedIn: function () {\n    let {\n      redirect: e\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      return Promise.resolve(C()).then(function (_ref30) {\n        let {\n          isLoggedIn: t\n        } = _ref30;\n        if (!t) return m();\n        if (U.usePkce) return;\n        if (e) return x(e);\n        if (O(\"redirect\")) return x(O(\"redirect\"));\n        const n = function (e, t) {\n          try {\n            var n = Promise.resolve(h(\"/self\", {\n              headers: {\n                authorization: `Bearer ${r.tokens.accessToken}`\n              }\n            })).then(function (_ref31) {\n              let {\n                data: e\n              } = _ref31;\n              e.tenant && e.tenant.loginRedirectPath && x(e.tenant.loginRedirectPath);\n            });\n          } catch (e) {\n            return t();\n          }\n          return n && n.then ? n.then(void 0, t) : n;\n        }(0, function () {\n          m();\n        });\n        return n && n.then ? n.then(function () {}) : void 0;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  redirectIfLoggedOut: function () {\n    let {\n      redirect: e\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      return Promise.resolve(C()).then(function (_ref32) {\n        let {\n          isLoggedIn: t\n        } = _ref32;\n        if (!t) return m(), e ? x(e) : O(\"redirect\") ? x(O(\"redirect\")) : void 0;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  user: a\n};\nexport { ne as default };","map":{"version":3,"names":["r","user","tokens","mode","n","e","t","split","replace","JSON","parse","atob","console","error","o","Date","exp","i","Error","response","data","message","s","window","a","c","u","baseUrl","Promise","resolve","put","reject","d","post","h","get","l","tenantId","secure","sameSite","set","f","location","pathname","hostname","slice","join","map","domain","path","remove","m","accessTokenName","idTokenName","refreshTokenName","accessToken","idToken","refreshToken","p","access","value","cookieOptions","id","refresh","P","w","then","v","exchange","_ref","k","headers","authorization","_ref2","status","warn","g","y","T","firstFactors","secondFactors","firstFactorToken","I","b","isMfaRequired","authentication","$","E","C","getSession","j","isLoggedIn","needsSecondFactor","resetMfaState","U","codeChallenge","usePkce","F","localStorage","removeItem","_","O","now","setItem","getItem","parseInt","N","code_challenge","z","URL","searchParams","assign","href","indexOf","decodeURIComponent","S","_ref3","redirect","x","redirectTo","document","createElement","hash","search","R","L","updatePasswordWithJwt","_ref4","password","existingPassword","Authorization","_ref5","A","_ref6","uuid","token","_ref7","M","updatePassword","_ref8","method","q","B","_ref9","provider","_ref10","origin","encodeURIComponent","D","K","_ref11","email","name","username","userData","options","_ref12","J","W","_ref13","channel","phoneNumber","V","sendVerificationCode","_ref14","_ref15","G","H","Q","X","setMode","_ref16","Y","reason","ee","Array","isArray","Z","match","protocol","update","Object","keys","length","hasRole","arguments","undefined","roles","getTotp","_ref17","_ref18","te","re","ne","addInitCallback","push","init","endsWith","defaults","common","forEach","registerUrlChangedEventListener","history","pushState","apply","dispatchEvent","Event","replaceState","addEventListener","logout","_ref19","userUuid","_ref20","login","userId","emailOrUsername","totpCode","backupCode","verificationCode","_ref21","noResetEmail","params","_ref22","hasOwnProperty","authorizationCode","_ref23","_ref24","_ref25","_ref26","resetPassword","sendLoginLink","_ref27","sendResetLink","_ref28","signup","_ref29","store","redirectIfLoggedIn","_ref30","_ref31","tenant","loginRedirectPath","redirectIfLoggedOut","_ref32","default"],"sources":["/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/store.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/utils.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/user.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/api.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/cookies.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/tokens.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/refresh.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/authentication.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/session.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/pkce.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/url.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/password.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/sso.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/link.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/verificationCode.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/totp.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/logout.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/constants.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/mode.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/user.methods.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/index.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/login.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/saml.js","/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/@userfront/core/src/signup.js"],"sourcesContent":["export const store = {\n  user: {},\n  tokens: {},\n  mode: \"live\",\n};\n","/**\n * This file is for zero-dependency utilities that can\n * be imported by any other file. Don't add any imports\n * to this file other than constants\n */\n\n/**\n * Get the unverified base64 decoded payload of a JWT\n *\n * @param {String} token - JSON Web Token\n * @returns {Object}\n */\nexport function getJwtPayload(token) {\n  try {\n    const encodedPayload = token\n      .split(\".\")[1]\n      .replace(\"-\", \"+\")\n      .replace(\"_\", \"/\");\n    return JSON.parse(atob(encodedPayload));\n  } catch (error) {\n    console.error(\"Problem decoding JWT payload\", error);\n  }\n}\n\n/**\n * Client-side check:\n * Determine whether the given JWT is present and unexpired\n *\n * @param {String} token JSON Web Token\n * @returns {Boolean}\n */\nexport function isJwtLocallyValid(token) {\n  try {\n    // Must be present\n    if (!token) {\n      return false;\n    }\n\n    // Must not be expired\n    const payload = getJwtPayload(token);\n    return new Date(payload.exp * 1000) > new Date();\n  } catch (error) {\n    return false;\n  }\n}\n\nexport function throwFormattedError(error) {\n  if (!error) return;\n  if (typeof error === \"string\") throw new Error(error);\n  if (error?.response?.data?.message) {\n    throw new Error(error.response.data.message);\n  }\n  throw error;\n}\n\nexport function isBrowser() {\n  return typeof window !== \"undefined\";\n}","import { store } from \"./store.js\";\nimport { getJwtPayload } from \"./utils.js\";\n\n/**\n * Define the store.user object based on the ID token\n */\nexport function setUser() {\n  if (!store.tokens.idToken) {\n    return console.warn(\"Cannot define user: missing ID token\");\n  }\n\n  store.user = store.user || {};\n  const idTokenPayload = getJwtPayload(store.tokens.idToken);\n\n  // Set basic user information properties from ID token\n  const propsToDefine = [\n    \"email\",\n    \"phoneNumber\",\n    \"username\",\n    \"name\",\n    \"image\",\n    \"data\",\n    \"confirmedAt\",\n    \"createdAt\",\n    \"updatedAt\",\n    \"mode\",\n    \"userId\",\n    \"userUuid\",\n    \"tenantId\",\n    \"isConfirmed\",\n  ];\n  for (const prop of propsToDefine) {\n    if (prop === \"update\") return;\n    store.user[prop] = idTokenPayload[prop];\n  }\n}\n\n/**\n * Remove all user information\n */\nexport function unsetUser() {\n  for (const attr in store.user) {\n    if (typeof store.user[attr] !== \"function\") {\n      delete store.user[attr];\n    }\n  }\n}\n\n/**\n * Export the store.user object with the update method added\n */\nexport const user = store.user;\n","import axios from \"axios\";\nimport { store } from \"./store.js\";\n\n// Replace multiple slashes // with single slash / (except in the protocol)\nfunction reduceSlashes(str) {\n  return str.replace(/([^:]\\/)\\/+/g, \"$1\");\n}\n\n/**\n * Perform a GET request\n * @param {String} path\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function get(path, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.get(url, options);\n}\n\n/**\n * Perform a POST request\n * @param {String} path\n * @param {Object} payload\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function post(path, payload, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.post(url, payload, options);\n}\n\n/**\n * Perform a PUT request\n * @param {String} path\n * @param {Object} payload\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function put(path, payload, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.put(url, payload, options);\n}\n\nexport default {\n  get,\n  post,\n  put,\n};\n","import Cookies from \"js-cookie\";\nimport { store } from \"./store.js\";\nimport { setTokensFromCookies, unsetTokens } from \"./tokens.js\";\n\n/**\n * Set a cookie value based on the given options.\n * @param {String} value\n * @param {Object} options\n * @param {String} type\n */\nexport function setCookie(value, options, type) {\n  const cookieName = `${type}.${store.tenantId}`;\n  options = options || {\n    secure: store.mode === \"live\",\n    sameSite: \"Lax\",\n  };\n  if (type === \"refresh\") {\n    options.sameSite = \"Strict\";\n  }\n  Cookies.set(cookieName, value, options);\n}\n\n/**\n * Remove a cookie by name, regardless of its cookie setting(s).\n * @param {String} name\n */\nfunction removeCookie(name) {\n  // Define all possible path and domain combinations\n  let paths, domains;\n  try {\n    const path = window.location.pathname;\n    const hostname = window.location.hostname;\n    const hostnameParts = hostname.split(\".\");\n    const primaryDomain = hostnameParts.slice(-2).join(\".\");\n    paths = [undefined, path, \"/\"];\n    domains = [\n      undefined,\n      hostname,\n      `.${hostname}`,\n      primaryDomain,\n      `.${primaryDomain}`,\n    ];\n  } catch (err) {\n    paths = [undefined, \"/\"];\n    domains = [undefined];\n  }\n\n  // Iterate over paths and domains, and remove cookies if present\n  paths.map((path) => {\n    domains.map((domain) => {\n      const options = {};\n      if (domain) options.domain = domain;\n      if (path) options.path = path;\n      Cookies.remove(name, options);\n    });\n  });\n}\n\n/**\n * Remove all auth cookies (access, id, refresh).\n */\nexport function removeAllCookies() {\n  removeCookie(store.tokens.accessTokenName);\n  removeCookie(store.tokens.idTokenName);\n  removeCookie(store.tokens.refreshTokenName);\n  unsetTokens();\n}\n\n/**\n * Set the cookies from a tokens object, and add to the local store.\n * @param {Object} tokens\n */\nexport function setCookiesAndTokens(tokens) {\n  setCookie(tokens.access.value, tokens.access.cookieOptions, \"access\");\n  setCookie(tokens.id.value, tokens.id.cookieOptions, \"id\");\n  if (tokens.refresh && tokens.refresh.value) {\n    setCookie(tokens.refresh.value, tokens.refresh.cookieOptions, \"refresh\");\n  }\n  setTokensFromCookies();\n}\n","import Cookies from \"js-cookie\";\nimport { store } from \"./store.js\";\nimport { setUser, unsetUser } from \"./user.js\";\nimport { refresh } from \"./refresh.js\";\nimport { isJwtLocallyValid } from \"./utils.js\";\n\nstore.tokens = store.tokens || {};\nstore.tokens.refresh = refresh;\n\nexport function setTokenNames() {\n  store.tokens = store.tokens || {};\n  store.tokens.accessTokenName = `access.${store.tenantId}`;\n  store.tokens.idTokenName = `id.${store.tenantId}`;\n  store.tokens.refreshTokenName = `refresh.${store.tenantId}`;\n}\n\n/**\n * Set and then return the access token\n */\nexport function accessToken() {\n  store.tokens.accessToken = Cookies.get(store.tokens.accessTokenName);\n  return store.tokens.accessToken;\n}\n\n/**\n * Set and then return the ID token\n */\nexport function idToken() {\n  store.tokens.idToken = Cookies.get(store.tokens.idTokenName);\n  return store.tokens.idToken;\n}\n\n/**\n * Define the store token values from the cookie values.\n */\nexport function setTokensFromCookies() {\n  const tokenNames = [\"access\", \"id\", \"refresh\"];\n  tokenNames.map((tokenName) => {\n    try {\n      const token = Cookies.get(store.tokens[`${tokenName}TokenName`]);\n      store.tokens[`${tokenName}Token`] = token;\n\n      // Set the user object whenever the ID token is set\n      if (tokenName === \"id\" && token) {\n        setUser();\n      }\n    } catch (error) {\n      console.warn(`Problem setting ${tokenName} token.`);\n    }\n  });\n}\n\n/**\n * Set the store token values to undefined\n */\nexport function unsetTokens() {\n  store.tokens.accessToken = undefined;\n  store.tokens.idToken = undefined;\n  store.tokens.refreshToken = undefined;\n  unsetUser();\n}\n\n/**\n * Client-side check:\n * Determine whether the access token is present and unexpired\n * @returns {Boolean}\n */\nexport function isAccessTokenLocallyValid() {\n  return isJwtLocallyValid(store.tokens.accessToken);\n}\n\n/**\n * Client-side check:\n * Determine whether the refresh token is present and unexpired\n * @returns {Boolean}\n */\nexport function isRefreshTokenLocallyValid() {\n  return isJwtLocallyValid(store.tokens.refreshToken);\n}\n\n/**\n * Export the store.tokens object\n */\nexport const tokens = store.tokens;\n\n// NOTE Commenting this out 6/11/21 because the packages it relies on (jsonwebtoken & jwks-rsa)\n// both cause a lot of bloat. If we want to verify tokens, this is a nice way to do it, but\n// we need to find libraries designed for the browser instead of node.\n/**\n * Verify the provided token\n * @param {String} token\n * @returns {Promise<void>} The provided token has been verified if `verifyToken` resolves without error\n */\n// export async function verifyToken(token) {\n//   if (!token) throw new Error(\"Missing token\");\n\n//   let publicKey;\n//   try {\n//     const decodedToken = jwt.decode(token, { complete: true });\n//     if (!decodedToken.header || !decodedToken.header.kid) {\n//       throw new Error(\"Token kid not defined\");\n//     }\n\n//     const client = new JwksClient({\n//       jwksUri: `${apiUrl}tenants/${store.tenantId}/jwks/${store.mode}`,\n//       requestHeaders: { origin: window.location.origin },\n//     });\n\n//     const key = await client.getSigningKey(decodedToken.header.kid);\n//     publicKey = key.getPublicKey();\n//   } catch (error) {\n//     throw error;\n//   }\n\n//   if (!publicKey) {\n//     throw new Error(\"Public key not found\");\n//   }\n\n//   try {\n//     jwt.verify(token, publicKey);\n//   } catch (error) {\n//     throw new Error(\"Token verification failed\");\n//   }\n\n//   return Promise.resolve();\n// }\n","import Cookies from \"js-cookie\";\nimport { get } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\n// import { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Refresh the access and ID tokens\n * - When in test mode, uses the basic refresh method\n * - For tenants without a custom SSL certificate, uses the basic refresh method\n * - For tenants with a custom SSL certificate and in live mode, uses the httpOnly refresh method\n * @returns {Promise}\n */\nexport async function refresh() {\n  try {\n    await basicRefresh();\n  } catch (error) {\n    console.warn(`Refresh failed: ${error.message}`);\n  }\n}\n\n/**\n * Use a regular (non-httpOnly) cookie to refresh the access and ID tokens.\n *\n * The basic refresh method is used automatically in test mode and in live\n * mode whenever an SSL certificate has not been set up.\n */\nasync function basicRefresh() {\n  const refreshToken = Cookies.get(store.tokens.refreshTokenName);\n  try {\n    const { data, status } = await get(`/auth/refresh`, {\n      headers: {\n        authorization: `Bearer ${refreshToken}`,\n      },\n    });\n    if (status !== 200) {\n      throw new Error(data.message || \"Problem with request\");\n    }\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      return data;\n    } else {\n      throw new Error(\"Problem setting cookies\");\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n// TODO re-enable httpOnly refresh method once new endpoints are stable [06/15/21]\n/**\n *\n * The httpOnly refresh method is only available for tenants with configured\n * SSL certificates while in live mode.\n */\n// async function httpOnlyRefresh() {\n//   const iframe = getIframe();\n//   if (!iframe) return;\n//   return postMessageAsPromise({\n//     type: \"refresh\",\n//     tenantId: store.tenantId,\n//   });\n// }\n\n/**\n * Use a sessionId and nonce to set the iframe refresh token\n * @param {String} sessionId\n * @param {String} nonce\n * @returns {Promise}\n */\nexport async function exchange({ sessionId, nonce }) {\n  return;\n\n  // TODO re-enable httpOnly exchange method once new endpoints are stable [06/15/21]\n  // --------------------------\n  // const iframe = getIframe();\n  // if (!iframe) return;\n  // return postMessageAsPromise({\n  //   type: \"exchange\",\n  //   tenantId: store.tenantId,\n  //   payload: {\n  //     sessionId,\n  //     nonce,\n  //   },\n  // });\n}\n","import { store } from \"./store.js\";\n\n// Data specific to the MFA service\nexport const authenticationData = {\n  firstFactors: [],\n  secondFactors: [],\n  firstFactorToken: null,\n};\n\n/**\n * Set authenticationData.firstFactors from the authentication object\n * @param {Object} authentication\n * {\n *   firstFactors,\n *   secondFactors\n * }\n * @returns\n */\nexport function setFirstFactors(authentication) {\n  // If we're not initialized, there are no first factors.\n  if (!store.tenantId) {\n    console.warn(\n      \"setFirstFactors: tried to set factors without a tenantId set.\"\n    );\n    return;\n  }\n  // If we're passed an invalid argument, keep the authentication data as is.\n  if (\n    !authentication ||\n    typeof authentication !== \"object\" ||\n    !Array.isArray(authentication.firstFactors)\n  ) {\n    console.warn(\"setFirstFactors: invalid factors passed.\");\n    return;\n  }\n  authenticationData.firstFactors = authentication.firstFactors;\n}\n\n/**\n * Check if MFA is required for the ongoing signup or login flow.\n * @returns {Boolean} true if MFA is currently required\n */\nexport function isMfaRequired() {\n  return !!authenticationData.firstFactorToken;\n}\n\n/**\n * Update the MFA service state given a response to a signup or login call.\n * Adds secondFactors and firstFactorToken if it is a MFA Required response,\n * removes them if it is a successful signup or login,\n * leaves the service unchanged otherwise.\n * @param {Object} response\n */\nexport function handleMfaRequired(response) {\n  if (!response.isMfaRequired) {\n    // If we've logged in or signed up successfully,\n    // clear the MFA service state.\n    if (response.message === \"OK\") {\n      clearMfa();\n    }\n    return;\n  }\n  authenticationData.secondFactors = response.authentication.secondFactors;\n  authenticationData.firstFactorToken = response.firstFactorToken;\n}\n\n/**\n * If MFA is required, returns a headers object with authorization set to the firstFactorToken.\n * Otherwise, returns an empty object.\n * @returns {Object} a headers object with MFA authorization header set, or empty if MFA is not required\n */\nexport function getMfaHeaders() {\n  if (authenticationData.firstFactorToken) {\n    return {\n      authorization: `Bearer ${authenticationData.firstFactorToken}`,\n    };\n  }\n  return {};\n}\n\n/**\n * Clears the current transient state of the MFA service,\n * leaving the tenant's persistent state in place.\n */\nexport function clearMfa() {\n  authenticationData.secondFactors = [];\n  authenticationData.firstFactorToken = null;\n}\n\n/**\n * Fully resets the MFA service, including the tenant's persistent state,\n * to it uninitialized state.\n */\nexport function resetMfa() {\n  clearMfa();\n  authenticationData.firstFactors = [];\n}\n","import {\n  isAccessTokenLocallyValid,\n  isRefreshTokenLocallyValid,\n} from \"./tokens.js\";\nimport {\n  authenticationData,\n  isMfaRequired,\n  clearMfa,\n} from \"./authentication.js\";\nimport { refresh } from \"./refresh.js\";\n\n/**\n * Determine whether a user is logged in by checking their\n * JWT access token and, if invalid, refreshing it and checking\n * again.\n * @returns {Promise<Boolean>}\n */\nasync function getIsLoggedIn() {\n  try {\n    // If the access token is locally valid, return true\n    if (isAccessTokenLocallyValid()) {\n      return true;\n    }\n\n    // If the refresh token is locally invalid, return false\n    if (!isRefreshTokenLocallyValid()) {\n      return false;\n    }\n\n    // Attempt to refresh the access token\n    await refresh();\n\n    // The access token should now be valid\n    return isAccessTokenLocallyValid();\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Return detailed information about the current session.\n * @returns {Promise<Object>}\n */\nexport async function getSession() {\n  const isLoggedIn = await getIsLoggedIn();\n  return {\n    isLoggedIn,\n    needsSecondFactor: isMfaRequired(),\n    firstFactors: authenticationData.firstFactors,\n    secondFactors: authenticationData.secondFactors,\n    resetMfaState: clearMfa,\n  };\n}\n","import { getQueryAttr } from \"./url.js\";\nimport { isBrowser } from \"./utils.js\";\n\nexport const store = {\n  codeChallenge: \"\",\n  get usePkce() {\n    return !!store.codeChallenge;\n  }\n}\n\n/**\n * Reads an unexpired challenge code from local storage\n * @returns {string?} the challenge code, if an unexpired one is in local storage\n */\nexport function readPkceDataFromLocalStorage() {\n  if (!isBrowser()) {\n    return;\n  }\n  const codeChallenge = window.localStorage.getItem(\"uf_pkce_code_challenge\");\n  if (codeChallenge) {\n    const expiresAt = window.localStorage.getItem(\"uf_pkce_code_challenge_expiresAt\");\n    if (expiresAt && (parseInt(expiresAt, 10) > Date.now())) {\n      return codeChallenge;\n    }\n  }\n}\n\n/**\n * Write a challenge code to local storage, expiring in 5 minutes\n * @param {string} codeChallenge \n * @returns \n */\nexport function writePkceDataToLocalStorage(codeChallenge) {\n  if (!isBrowser()) {\n    return;\n  }\n  if (!codeChallenge) {\n    return clearPkceDataFromLocalStorage();\n  }\n  store.codeChallenge = codeChallenge;\n  const expiresAt = (Date.now() + 1000 * 60 * 5); // 5 minutes from now\n  try {\n    window.localStorage.setItem(\"uf_pkce_code_challenge\", codeChallenge);\n    window.localStorage.setItem(\"uf_pkce_code_challenge_expiresAt\", expiresAt);\n  } catch (err) {\n    // Suppress exception from full local storage\n  }\n}\n\n/**\n * Clear the challenge code and expiration from local storage\n */\nexport function clearPkceDataFromLocalStorage() {\n  if (!isBrowser()) {\n    return;\n  }\n  window.localStorage.removeItem(\"uf_pkce_code_challenge\");\n  window.localStorage.removeItem(\"uf_pkce_code_challenge_expiresAt\");\n}\n\n/**\n * Set up the PKCE service: look for a PKCE challenge code in\n * query params or local storage. If both are present, the query\n * param is preferred.\n * @returns {Boolean} true if we should use PKCE in our auth requests\n */\nexport function setupPkce() {\n  if (!isBrowser()) {\n    return;\n  }\n  const codeChallengeFromQueryParams = getQueryAttr(\"code_challenge\");\n  if (codeChallengeFromQueryParams) {\n    store.codeChallenge = codeChallengeFromQueryParams;\n    writePkceDataToLocalStorage(codeChallengeFromQueryParams);\n    return true;\n  }\n  const codeChallengeFromLocalStorage = readPkceDataFromLocalStorage();\n  if (codeChallengeFromLocalStorage) {\n    store.codeChallenge = codeChallengeFromLocalStorage;\n    return true;\n  }\n  clearPkceDataFromLocalStorage();\n  return false;\n}\n\n/**\n * Get (possibly empty) PKCE query params to attach to an auth request\n * @returns {object} an object to be used for an Axios request's params field\n */\nexport function getPkceRequestQueryParams() {\n  if (!store.usePkce) {\n    return {};\n  }\n  return { \"code_challenge\": store.codeChallenge };\n}\n\n/**\n * Redirect to url with PKCE query params (authorization_code) set. Does not redirect\n * if url or authorizationCode are falsy.\n * \n * @param {string} url full URL to redirect to (may be a deep link for a mobile app)\n * @param {string} authorizationCode the authorization code received from the server\n * @returns \n */\nexport function redirectWithPkce(url, authorizationCode) {\n  if (!url || !authorizationCode) {\n    return;\n  }\n  if (!store.usePkce) {\n    console.warn(\"Redirecting with a PKCE authorization code, but no PKCE challenge code is present in the client. This is unexpected.\")\n  }\n  const _url = new URL(url);\n  _url.searchParams.set(\"authorization_code\", authorizationCode);\n  clearPkceDataFromLocalStorage();\n  window.location.assign(_url.href);\n}","import { get } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\nimport { getSession } from \"./session.js\";\nimport { store as pkceStore } from \"./pkce.js\";\n\n/**\n * Get the value of a query attribute, e.g. ?attr=value\n * @param {String} attrName\n */\nexport function getQueryAttr(attrName) {\n  if (\n    typeof window !== \"object\" ||\n    typeof window.location !== \"object\" ||\n    !window.location.href ||\n    window.location.href.indexOf(`${attrName}=`) < 0\n  ) {\n    return;\n  }\n  return decodeURIComponent(\n    window.location.href.split(`${attrName}=`)[1].split(\"&\")[0]\n  );\n}\n\n/**\n * Redirect the browser based on explicit redirect input path, or the API response\n * @property {String|Boolean} redirect A path to redirect to, or false to not redirect\n * @property {Object} data The response object from the API\n * @returns\n */\nexport const handleRedirect = ({ redirect, data }) => {\n  if (redirect === false) return;\n  const path = redirect || getQueryAttr(\"redirect\") || data.redirectTo || \"/\";\n  redirectToPath(path);\n};\n\n/**\n * If the access token is valid, redirect the browser to the\n * tenant's After-login path.\n */\nexport async function redirectIfLoggedIn({ redirect } = {}) {\n  const { isLoggedIn } = await getSession();\n  if (!isLoggedIn) {\n    return removeAllCookies();\n  }\n\n  // TODO see #130: can handle this more elegantly once we have an exchange tokens -> authorizationCode\n  // endpoint on the server.\n  // If this is a PKCE auth session, don't redirect with this function ever.\n  // The only way to get an authorizationCode currently is to go through an auth flow.\n  // The PKCE module handles redirect after a PKCE Required response is received.\n  if (pkceStore.usePkce) {\n    return;\n  }\n\n  // Redirect to a provided path (check options first, then url querystring)\n  if (redirect) {\n    return redirectToPath(redirect);\n  } else if (getQueryAttr(\"redirect\")) {\n    return redirectToPath(getQueryAttr(\"redirect\"));\n  }\n\n  // If no path was provided, look up the path and then redirect there\n  try {\n    const { data } = await get(`/self`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    if (data.tenant && data.tenant.loginRedirectPath) {\n      redirectToPath(data.tenant.loginRedirectPath);\n    }\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\n/**\n * If the access token is invalid, redirect the browser to the\n * provided path.\n */\nexport async function redirectIfLoggedOut({ redirect } = {}) {\n  // If the user is logged in, return without doing anything\n  const { isLoggedIn } = await getSession();\n  if (isLoggedIn) {\n    return;\n  }\n\n  // Remove all cookies\n  removeAllCookies();\n\n  // Redirect to a provided path (check options first, then url querystring)\n  if (redirect) {\n    return redirectToPath(redirect);\n  } else if (getQueryAttr(\"redirect\")) {\n    return redirectToPath(getQueryAttr(\"redirect\"));\n  }\n\n  // If no redirect path was provided, do not redirect\n  return;\n}\n\n/**\n * Redirect to path portion of a URL.\n */\nexport function redirectToPath(pathOrUrl) {\n  // Return if no pathOrUrl, or if SSR or mobile\n  if (\n    !pathOrUrl ||\n    typeof document !== \"object\" ||\n    typeof window !== \"object\"\n  ) {\n    return;\n  }\n  try {\n    document && window;\n  } catch (error) {\n    return;\n  }\n\n  // Perform hard redirect\n  const el = document.createElement(\"a\");\n  el.href = pathOrUrl;\n  let path = `${el.pathname}${el.hash}${el.search}`;\n  if (el.pathname !== window.location.pathname) {\n    window.location.assign(path);\n  }\n}\n","import { post, put } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { getQueryAttr, handleRedirect } from \"./url.js\";\nimport { throwFormattedError } from \"./utils.js\";\nimport { exchange } from \"./refresh.js\";\nimport {\n  getMfaHeaders,\n  handleMfaRequired,\n  clearMfa,\n} from \"./authentication.js\";\nimport { getPkceRequestQueryParams, redirectWithPkce } from \"./pkce.js\";\n\n/**\n * Register a new user with username, name, email, and password.\n * Redirect the browser after successful signup based on the redirectTo value returned.\n * @param {String} username\n * @param {String} name\n * @param {String} email\n * @param {String} password\n * @param {Object} userData - alias for the user.data object, since \"data\" is used in the response\n * @param {String} redirect - do not redirect if false, or redirect to a specific path\n */\nexport async function signupWithPassword({\n  username,\n  name,\n  email,\n  password,\n  userData,\n  redirect,\n} = {}) {\n  try {\n    const { data } = await post(\n      `/auth/create`,\n      {\n        tenantId: store.tenantId,\n        username,\n        name,\n        email,\n        password,\n        data: userData,\n      },\n      {\n        headers: getMfaHeaders(),\n        params: getPkceRequestQueryParams(),\n      }\n    );\n    if (data.tokens) {\n      clearMfa();\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    } else if (data.firstFactorToken) {\n      handleMfaRequired(data);\n      return data;\n    } else if (data.authorizationCode) {\n      const url = redirect || data.redirectTo;\n      if (url) {\n        redirectWithPkce(url, data.authorizationCode);\n      } else {\n        // We can't exchange the authorizationCode for tokens, because we don't have the verifier code\n        // that matches our challenge code.\n        throw new Error(\"Received a PKCE (mobile auth) response from the server, but no redirect was provided. Please set the redirect to the app that initiated the request.\")\n      }\n    } else {\n      throw new Error(\"Please try again.\");\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log a user in with email/username and password.\n * Redirect the browser after successful login based on the redirectTo value returned.\n * @param {Object} params\n * @param {string} params.email The user's email. One of email/username/emailOrUsername should be present.\n * @param {string} params.username The user's username. One of email/username/emailOrUsername should be present.\n * @param {string} params.emailOrUsername Either the user's email or username. One of email/username/emailOrUsername should be present.\n * @param {string} params.password\n * @param {string | boolean} params.redirect \n *  URL to redirect to after login, or false to suppress redirect. Otherwise, redirects to the after-login path set on the server.\n * @param {object} params.options\n * @param {boolean} params.options.noResetEmail\n *  By default, Userfront sends a password reset email if a user without a password tries to log in with a password.\n *  Set options.noResetEmail = true to override this behavior and return an error instead.\n * \n */\nexport async function loginWithPassword({\n  email,\n  username,\n  emailOrUsername,\n  password,\n  redirect,\n  options\n}) {\n  try {\n    const body = {\n      tenantId: store.tenantId,\n      emailOrUsername: email || username || emailOrUsername,\n      password,\n    };\n    if (options && options.noResetEmail) {\n      body.options = {\n        noResetEmail: true\n      }\n    }\n    const { data } = await post(\n      `/auth/basic`,\n      body,\n      {\n        headers: getMfaHeaders(),\n        params: getPkceRequestQueryParams(),\n      }\n    );\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorToken\")) {\n      handleMfaRequired(data);\n      return data;\n    }\n\n    if (data.authorizationCode) {\n      const url = redirect || data.redirectTo;\n      if (url) {\n        redirectWithPkce(url, data.authorizationCode);\n        return;\n      } else {\n        // TODO this is neither valid nor invalid\n      }\n    }\n\n    throw new Error(\"Please try again.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Send a password reset link to the provided email.\n * @param {String} email\n */\nexport async function sendResetLink(email) {\n  try {\n    const { data } = await post(`/auth/reset/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Set a user's password with their link credentials or JWT access token.\n *\n * If no method is provided, the order is:\n * - Check for link credentials; then\n * - Check for a JWT access token first\n *\n * @property {String} method (optional) \"link\" or \"jwt\"\n * @property {String} password\n * @property {String} existingPassword\n * @property {String} uuid\n * @property {String} token\n * @property {String} redirect\n * @returns\n */\nexport async function updatePassword({\n  method,\n  password,\n  existingPassword,\n  uuid,\n  token,\n  redirect,\n}) {\n  switch (method) {\n    // Allow for explicit setting of method\n    case \"link\":\n      return updatePasswordWithLink({ uuid, token, password, redirect });\n    case \"jwt\":\n      return updatePasswordWithJwt({ password, existingPassword });\n    default:\n      // Default (no method provided) is to look for link credentials first, then JWT access token\n      token = token || getQueryAttr(\"token\");\n      uuid = uuid || getQueryAttr(\"uuid\");\n      if (uuid && token) {\n        return updatePasswordWithLink({ uuid, token, password, redirect });\n      } else if (store.tokens.accessToken) {\n        return updatePasswordWithJwt({ password, existingPassword });\n      } else {\n        throw new Error(\n          \"updatePassword() was called without link credentials (token & uuid) or a JWT access token.\"\n        );\n      }\n  }\n}\n\nexport const resetPassword = updatePassword;\n\nexport async function updatePasswordWithLink({\n  uuid,\n  token,\n  password,\n  redirect,\n}) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) throw new Error(\"Missing token or uuid\");\n    const { data } = await put(`/auth/reset`, {\n      tenantId: store.tenantId,\n      uuid,\n      token,\n      password,\n    });\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      handleRedirect({ redirect, data });\n      return data;\n    } else {\n      throw new Error(\n        \"There was a problem resetting your password. Please try again.\"\n      );\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\nexport async function updatePasswordWithJwt({ password, existingPassword }) {\n  try {\n    if (!store.tokens.accessToken) {\n      throw new Error(\n        `updatePassword({ method: \"jwt\" }) was called without a JWT access token.`\n      );\n    }\n\n    const { data } = await put(\n      `/auth/basic`,\n      {\n        tenantId: store.tenantId,\n        password,\n        existingPassword,\n      },\n      {\n        headers: {\n          Authorization: `Bearer ${store.tokens.accessToken}`,\n        },\n      }\n    );\n\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { store } from \"./store.js\";\nimport { getQueryAttr } from \"./url.js\";\n\nexport function getProviderLink({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  if (!store.tenantId) throw new Error(\"Missing tenantId\");\n\n  let url = `${store.baseUrl}auth/${provider}/login?tenant_id=${store.tenantId}&origin=${window.location.origin}`;\n\n  let redirectTo = redirect || getQueryAttr(\"redirect\");\n  if (redirect === false) {\n    redirectTo = typeof document === \"object\" && document.location.pathname;\n  }\n  if (redirectTo) {\n    url += `&redirect=${encodeURIComponent(redirectTo)}`;\n  }\n\n  return url;\n}\n\n/**\n * Log in or register a user via SSO provider.\n * Redirect the browser after successful authentication and 302 redirect from server.\n * @param {String} provider Name of SSO provider\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport function signonWithSso({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  const url = getProviderLink({ provider, redirect });\n  window.location.assign(url);\n}\n","import { post, put } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { getQueryAttr, handleRedirect } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\nimport {\n  getMfaHeaders,\n  handleMfaRequired,\n  clearMfa,\n} from \"./authentication.js\";\nimport { getPkceRequestQueryParams, redirectWithPkce } from \"./pkce.js\";\n\n/**\n * Log a user in with a token/uuid combo passed into the function or\n * in the URL querystring. ?token=...&uuid=...\n * @param {String} token\n * @param {UUID} uuid\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithLink({ token, uuid, redirect } = {}) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) return;\n\n    const { data } = await put(\n      \"/auth/link\",\n      {\n        token,\n        uuid,\n        tenantId: store.tenantId,\n      },\n      {\n        headers: getMfaHeaders(),\n        params: getPkceRequestQueryParams()\n      }\n    );\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      clearMfa();\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorToken\")) {\n      handleMfaRequired(data);\n      return data;\n    }\n\n    if (data.authorizationCode) {\n      const url = redirect || data.redirectTo;\n      if (url) {\n        redirectWithPkce(url, data.authorizationCode);\n        return;\n      } else {\n        // We can't exchange the authorizationCode for tokens, because we don't have the verifier code\n        // that matches our challenge code.\n        throw new Error(\"Received a PKCE (mobile auth) response from the server, but no redirect was provided. Please set the redirect to the app that initiated the request.\")\n      }\n    }\n\n    throw new Error(\"Problem logging in.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Send a login link to the provided email.\n * @param {String} email\n */\nexport async function sendLoginLink(email) {\n  try {\n    const { data } = await post(`/auth/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Create or update a user and send them a link to log in.\n * @param {Object} inputs\n */\nexport async function sendPasswordlessLink({\n  email,\n  name,\n  username,\n  userData,\n  options,\n}) {\n  try {\n    const { data } = await post(`/auth/link`, {\n      email,\n      name,\n      username,\n      data: userData,\n      options,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { post, put } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { handleRedirect } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\nimport {\n  getMfaHeaders,\n  handleMfaRequired,\n  clearMfa,\n} from \"./authentication.js\";\nimport { getPkceRequestQueryParams, redirectWithPkce } from \"./pkce.js\";\n\n/**\n * Verify that proper identifier is available for the channel\n * @property {String} channel \"sms\" or \"email\"\n * @property {String} phoneNumber\n * @property {String} email\n */\nfunction enforceChannel({ channel, phoneNumber, email }) {\n  if (channel !== \"sms\" && channel !== \"email\") {\n    throw new Error(\"Invalid channel\");\n  }\n  if (channel === \"sms\" && !phoneNumber) {\n    throw new Error(`SMS verification code requires \"phoneNumber\"`);\n  } else if (channel === \"email\" && !email) {\n    throw new Error(`Email verification code requires \"email\"`);\n  }\n}\n\n/**\n * Send a verification code to the provided email address or phone number.\n * @property {String} channel \"sms\" (default) or \"email\"\n * @property {String} phoneNumber\n * @property {String} email\n * @property {String} name\n * @property {String} username\n * @property {Object} data\n */\nexport async function sendVerificationCode({\n  channel = \"sms\",\n  phoneNumber,\n  email,\n  name,\n  username,\n  data,\n}) {\n  try {\n    enforceChannel({\n      channel,\n      phoneNumber,\n      email,\n    });\n\n    const { data: res } = await post(`/auth/code`, {\n      channel,\n      email,\n      phoneNumber,\n      name,\n      username,\n      data,\n      tenantId: store.tenantId,\n    }, {\n      headers: getMfaHeaders()\n    });\n    return res;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log a user in with a token/uuid combo passed into the function or\n * in the URL querystring. ?token=...&uuid=...\n * @param {String} token\n * @param {UUID} uuid\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithVerificationCode({\n  channel,\n  verificationCode,\n  email,\n  phoneNumber,\n  redirect,\n} = {}) {\n  try {\n    enforceChannel({\n      channel,\n      phoneNumber,\n      email,\n    });\n\n    const { data } = await put(\n      `/auth/code`,\n      {\n        channel,\n        verificationCode,\n        email,\n        phoneNumber,\n        tenantId: store.tenantId,\n      },\n      {\n        headers: getMfaHeaders(),\n        params: getPkceRequestQueryParams(),\n      }\n    );\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      clearMfa();\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorToken\")) {\n      handleMfaRequired(data);\n      return data;\n    }\n\n    if (data.authorizationCode) {\n      const url = redirect || data.redirectTo;\n      if (url) {\n        redirectWithPkce(url, data.authorizationCode);\n        return;\n      } else {\n        // We can't exchange the authorizationCode for tokens, because we don't have the verifier code\n        // that matches our challenge code.\n        throw new Error(\"Received a PKCE (mobile auth) response from the server, but no redirect was provided. Please set the redirect to the app that initiated the request.\")\n      }\n    }\n\n    throw new Error(\"Problem logging in.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { get, post } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { handleRedirect } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\nimport {\n  isMfaRequired,\n  getMfaHeaders,\n  handleMfaRequired,\n  clearMfa,\n} from \"./authentication.js\";\nimport { getPkceRequestQueryParams, redirectWithPkce } from \"./pkce.js\";\n\n/**\n * Log a user in with a TOTP authenticator code or a TOTP backup code,\n * plus an identifier for the user (e.g. userId, userUuid, or email)\n *\n * @property {String} totpCode \"123456\"\n * @property {String} backupCode \"aaaaa-bbbbb\"\n * @property {Integer} userId\n * @property {String} userUuid\n * @property {String} emailOrUsername\n * @property {String} email\n * @property {String} username\n * @property {String} phoneNumber\n * @property {String|Boolean} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithTotp({\n  totpCode,\n  backupCode,\n  userId,\n  userUuid,\n  emailOrUsername,\n  email,\n  username,\n  phoneNumber,\n  redirect,\n} = {}) {\n  try {\n\n    const { data } = await post(\n      `/auth/totp`,\n      {\n        totpCode,\n        backupCode,\n        userId,\n        userUuid,\n        emailOrUsername,\n        email,\n        username,\n        phoneNumber,\n        tenantId: store.tenantId,\n      },\n      {\n        headers: getMfaHeaders(),\n        params: getPkceRequestQueryParams(),\n      }\n    );\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      clearMfa();\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorToken\")) {\n      handleMfaRequired(data);\n      return data;\n    }\n\n    if (data.authorizationCode) {\n      const url = redirect || data.redirectTo;\n      if (url) {\n        redirectWithPkce(url, data.authorizationCode);\n        return;\n      } else {\n        // We can't exchange the authorizationCode for tokens, because we don't have the verifier code\n        // that matches our challenge code.\n        throw new Error(\"Received a PKCE (mobile auth) response from the server, but no redirect was provided. Please set the redirect to the app that initiated the request.\")\n      }\n    }\n\n    throw new Error(\"Problem logging in.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\nexport async function getTotp() {\n  try {\n    if (isMfaRequired()) {\n      const { data } = await get(`/auth/totp`, {\n        headers: getMfaHeaders(),\n      });\n      return data;\n    }\n    if (!store.tokens.accessToken) {\n      throw new Error(`getTotp() was called without a JWT access token.`);\n    }\n\n    const { data } = await get(`/auth/totp`, {\n      headers: {\n        Authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { get } from \"./api.js\";\nimport { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\nimport { setTokensFromCookies } from \"./tokens.js\";\nimport { handleRedirect } from \"./url\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Log a user out and redirect to the logout path.\n */\nexport async function logout({ method, redirect } = {}) {\n  if (method === \"saml\") {\n    return completeSamlLogout();\n  }\n  if (!store.tokens.accessToken) {\n    return removeAllCookies();\n  }\n\n  try {\n    const { data } = await get(`/auth/logout`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    removeAllCookies();\n    handleRedirect({ redirect, data });\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\nasync function completeSamlLogout() {\n  if (!store.tokens.accessToken) {\n    throw new Error(\"Please log in to authorize your logout request.\");\n  }\n\n  try {\n    const { data } = await get(`/auth/saml/idp/token`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    window.location.assign(\n      `${store.baseUrl}auth/saml/idp/logout?tenant_id=${store.tenantId}&token=${data.token}&uuid=${store.user.userUuid}`\n    );\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n// TODO re-enable exchange method once new endpoints are stable [06/15/21]\n// --------------------------\n// const iframe = getIframe();\n// if (!iframe) return;\n// try {\n//   const { data } = await postMessageAsPromise({\n//     type: \"logout\",\n//     tenantId: store.tenantId,\n//   });\n//   removeAllCookies();\n//   setTokensFromCookies();\n//   handleRedirect({ redirect, data });\n// } catch (error) {\n//   removeAllCookies();\n//   redirectToPath(\"/\");\n// }\n","export const apiUrl = `https://api.userfront.com/v0/`;\n\nexport const privateIPRegex =\n  /((^127\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.))\\d{1,3}\\.\\d{1,3}/g;\n","import { get } from \"./api.js\";\nimport { privateIPRegex } from \"./constants.js\";\nimport { store } from \"./store.js\";\nimport { setFirstFactors } from \"./authentication.js\";\n\n/**\n * Global mode object\n */\nexport const mode = {\n  value: \"live\",\n  reason: undefined,\n  setMode,\n};\n\nsetModeSync();\n\n/**\n * Determine whether a hostname is in test mode.\n * @param {String} hn\n */\nexport function isTestHostname(hn) {\n  try {\n    const hostname = hn || window.location.hostname;\n    return !!(hostname.match(/localhost/g) || hostname.match(privateIPRegex));\n  } catch (err) {\n    return true;\n  }\n}\n\nexport function isHttps() {\n  try {\n    return window.location.protocol === \"https:\";\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Define the mode of operation (live or test)\n * and the tenant's authentication factors\n */\nexport async function setMode() {\n  try {\n    const { data } = await get(`/tenants/${store.tenantId}/mode`);\n    mode.value = data.mode || \"test\";\n    mode.reason = getReason(mode.value);\n    store.mode = mode.value;\n    setFirstFactors(data.authentication);\n    return data;\n  } catch (err) {\n    mode.value = \"test\";\n    store.mode = mode.value;\n  }\n}\n\n/**\n * Estimate the mode without making an API call\n */\nexport function setModeSync() {\n  const modeValue = isTestHostname() || !isHttps() ? \"test\" : \"live\";\n  mode.value = modeValue;\n  mode.reason = getReason(modeValue);\n  store.mode = modeValue;\n}\n\n/**\n * Set the reason for the mode\n * - http\n * - domain\n */\nfunction getReason(mode) {\n  try {\n    if (mode === \"live\") {\n      return \"domain\";\n    }\n    if (window.location.protocol === \"http:\") {\n      return \"http\";\n    } else if (window.location.protocol !== \"https:\") {\n      return \"protocol\";\n    } else {\n      return \"domain\";\n    }\n  } catch (error) {}\n}\n","/**\n * user methods are refactored into a separate file to avoid a circular dependency\n * between Userfront.refresh() [which requires setUser()]\n * and Userfront.user.update() [which requires refresh()].\n */\nimport { put } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { refresh } from \"./refresh.js\";\nimport { getTotp } from \"./totp.js\";\nimport { getJwtPayload } from \"./utils.js\";\nimport { updatePassword } from \"./password.js\";\n\n/**\n * Update the user record on Userfront\n * @param {Object} payload User properties to update e.g. { name: 'John Doe' }\n */\nexport async function update(payload) {\n  if (!payload || Object.keys(payload).length < 1) {\n    return console.warn(\"Missing user properties to update\");\n  }\n\n  // Make request to update the user\n  await put(`/self`, payload, {\n    headers: {\n      authorization: `Bearer ${store.tokens.accessToken}`,\n    },\n  });\n\n  // Refresh the access and ID tokens, and set the store.user object from the ID token\n  await refresh();\n\n  return store.user;\n}\n\n/**\n * Determine whether the access token has a given role\n * @param {String} roleName\n * @param {Object} options\n * @returns {Boolean}\n */\nexport function hasRole(roleName, { tenantId } = {}) {\n  try {\n    if (!store.tokens.accessToken || !store.tenantId) {\n      return false;\n    }\n    const { authorization } = getJwtPayload(store.tokens.accessToken);\n    if (!authorization) {\n      return false;\n    }\n    tenantId = tenantId || store.tenantId;\n    if (!authorization[tenantId] || !authorization[tenantId].roles) {\n      return false;\n    }\n    return authorization[tenantId].roles.indexOf(roleName) > -1;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Add the methods to the store.user object\n */\nstore.user.update = update;\nstore.user.hasRole = hasRole;\nstore.user.updatePassword = updatePassword;\nstore.user.getTotp = getTotp;\n","import axios from \"axios\";\nimport { store } from \"./store.js\";\nimport {\n  tokens,\n  accessToken,\n  idToken,\n  setTokensFromCookies,\n  setTokenNames,\n} from \"./tokens\";\nimport { getSession } from \"./session\";\nimport { redirectIfLoggedIn, redirectIfLoggedOut } from \"./url.js\";\nimport { signup } from \"./signup.js\";\nimport { login } from \"./login.js\";\nimport { updatePassword, resetPassword, sendResetLink } from \"./password.js\";\nimport { sendLoginLink } from \"./link.js\";\nimport { sendVerificationCode } from \"./verificationCode\";\nimport { logout } from \"./logout.js\";\nimport { mode, setMode, setModeSync } from \"./mode.js\";\n// import { setIframe } from \"./iframe.js\";\nimport { user } from \"./user.js\";\nimport \"./user.methods.js\";\nimport { refresh } from \"./refresh.js\";\nimport { apiUrl } from \"./constants.js\";\nimport { resetMfa } from \"./authentication.js\";\n\nlet initCallbacks = [];\n\n/**\n * Initialize the Userfront library.\n * @param {String} tenantId\n */\nfunction init(tenantId, opts = {}) {\n  if (!tenantId) return console.warn(\"Userfront initialized without tenantId\");\n\n  store.tenantId = tenantId;\n\n  store.baseUrl = opts.baseUrl || apiUrl;\n  if (!store.baseUrl.endsWith(\"/\")) {\n    store.baseUrl += \"/\";\n  }\n\n  if (opts.domain) {\n    store.domain = opts.domain;\n    const url = `https://${store.domain}`;\n    axios.defaults.headers.common[\"x-application-id\"] = url;\n    axios.defaults.headers.common[\"x-origin\"] = url;\n  }\n\n  setTokenNames();\n  // setIframe(); // TODO re-enable when iframe is needed\n  setTokensFromCookies();\n\n  // Estimate the mode synchronously with local data.\n  // Clients that require the true mode or the default\n  // authenticationData should call and await setMode.\n  setModeSync();\n\n  resetMfa();\n\n  try {\n    if (initCallbacks.length > 0) {\n      initCallbacks.forEach((cb) => {\n        if (!cb || typeof cb !== \"function\") return;\n        cb({ tenantId });\n      });\n    }\n    initCallbacks = [];\n  } catch (error) {}\n}\n\n/**\n * Add a callback function to be called upon Userfront.init()\n * @param {Function} cb\n */\nfunction addInitCallback(cb) {\n  if (!cb || typeof cb !== \"function\") return;\n  initCallbacks.push(cb);\n}\n\n/**\n\n * Register a window-level event called \"urlchanged\" that will fire\n * whenever the browser URL changes.\n */\nlet isRegistered = false;\nfunction registerUrlChangedEventListener() {\n  if (isRegistered) return;\n  isRegistered = true;\n  try {\n    history.pushState = ((f) =>\n      function pushState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"pushstate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.pushState);\n\n    history.replaceState = ((f) =>\n      function replaceState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"replacestate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.replaceState);\n\n    window.addEventListener(\"popstate\", () => {\n      window.dispatchEvent(new Event(\"urlchanged\"));\n    });\n  } catch (error) {}\n}\n\n/**\n * EXPORTS\n */\n\nexport default {\n  // index\n  addInitCallback,\n  init,\n  registerUrlChangedEventListener,\n\n  //logout\n  logout,\n\n  // mode\n  mode,\n  setMode,\n\n  // refresh\n  refresh: (a, b, c) => {\n    try {\n      console.warn(\n        \"Userfront.refresh() is deprecated and will be removed. Please use Userfront.tokens.refresh() instead.\"\n      );\n    } catch (error) {}\n    return refresh(a, b, c);\n  },\n\n  // signon\n  login,\n  resetPassword,\n  updatePassword,\n  sendLoginLink,\n  sendResetLink,\n  sendVerificationCode,\n  signup,\n\n  // store\n  store,\n\n  // tokens\n  tokens,\n  accessToken,\n  idToken,\n\n  // session\n  getSession,\n\n  // url\n  redirectIfLoggedIn,\n  redirectIfLoggedOut,\n\n  // user\n  user,\n\n  // utils\n};\n","import { loginWithPassword } from \"./password.js\";\nimport { loginWithLink, sendPasswordlessLink } from \"./link.js\";\nimport { signonWithSso } from \"./sso.js\";\nimport { loginWithTotp } from \"./totp.js\";\nimport { loginWithVerificationCode } from \"./verificationCode.js\";\nimport { completeSamlLogin } from \"./saml.js\";\nimport { setupPkce } from \"./pkce.js\";\n\n/**\n * Log a user in via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {String} method\n * @param {Number} userId\n * @param {String} userUuid\n * @param {String} email\n * @param {String} username\n * @param {String} emailOrUsername\n * @param {String} phoneNumber\n * @param {String} password\n * @param {String} token\n * @param {String} uuid\n * @param {String} totpCode\n * @param {String} backupCode\n * @param {String} channel \"sms\" or \"email\"\n * @param {String} verificationCode\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function login({\n  method,\n  // User identifiers\n  userId,\n  userUuid,\n  email,\n  username,\n  emailOrUsername,\n  phoneNumber,\n  // Password\n  password,\n  // Link\n  token,\n  uuid,\n  // Totp\n  totpCode,\n  backupCode,\n  // Verification code\n  channel,\n  verificationCode,\n  // Other\n  redirect,\n  options,\n} = {}) {\n  if (!method) {\n    throw new Error('Userfront.login called without \"method\" property.');\n  }\n  setupPkce();\n  switch (method) {\n    case \"apple\":\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return signonWithSso({ provider: method, redirect });\n    case \"password\":\n      return loginWithPassword({\n        email,\n        username,\n        emailOrUsername,\n        password,\n        redirect,\n        options,\n      });\n    case \"passwordless\":\n      return sendPasswordlessLink({ email });\n    case \"link\":\n      return loginWithLink({ token, uuid, redirect });\n    case \"totp\":\n      return loginWithTotp({\n        totpCode,\n        backupCode,\n        userId,\n        userUuid,\n        emailOrUsername,\n        email,\n        username,\n        phoneNumber,\n        redirect,\n      });\n    case \"verificationCode\":\n      return loginWithVerificationCode({\n        channel,\n        email,\n        phoneNumber,\n        verificationCode,\n        redirect,\n      });\n    case \"saml\":\n      return completeSamlLogin();\n    default:\n      throw new Error('Userfront.login called with invalid \"method\" property.');\n  }\n}\n","import { get } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\nexport async function completeSamlLogin() {\n  try {\n    if (!store.tokens.accessToken) {\n      return console.warn(\"Cannot complete SAML login without access token\");\n    }\n\n    const { data } = await get(`/auth/saml/idp/token`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    window.location.assign(\n      `${store.baseUrl}auth/saml/idp/login?tenant_id=${store.tenantId}&token=${data.token}&uuid=${store.user.userUuid}`\n    );\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { signupWithPassword } from \"./password.js\";\nimport { signonWithSso } from \"./sso.js\";\nimport { sendPasswordlessLink } from \"./link.js\";\nimport { sendVerificationCode } from \"./verificationCode.js\";\nimport { setupPkce } from \"./pkce.js\";\n\n/**\n * Register a user via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {String} method\n * @param {String} email\n * @param {String} username\n * @param {String} phoneNumber\n * @param {String} name\n * @param {Object} data - Object for custom user fields\n * @param {String} password\n * @param {String} channel \"sms\" or \"email\"\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function signup({\n  method,\n  email,\n  username,\n  phoneNumber,\n  name,\n  data,\n  password,\n  channel,\n  redirect,\n} = {}) {\n  setupPkce();\n  if (!method) {\n    throw new Error('Userfront.signup called without \"method\" property.');\n  }\n  switch (method) {\n    case \"apple\":\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return signonWithSso({ provider: method, redirect });\n    case \"password\":\n      return signupWithPassword({\n        username,\n        name,\n        email,\n        password,\n        userData: data,\n        redirect,\n      });\n    case \"passwordless\":\n      return sendPasswordlessLink({ email, name, username, userData: data });\n    case \"verificationCode\":\n      return sendVerificationCode({\n        channel,\n        email,\n        phoneNumber,\n        name,\n        username,\n        data,\n      });\n    default:\n      throw new Error(\n        'Userfront.signup called with invalid \"method\" property.'\n      );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}