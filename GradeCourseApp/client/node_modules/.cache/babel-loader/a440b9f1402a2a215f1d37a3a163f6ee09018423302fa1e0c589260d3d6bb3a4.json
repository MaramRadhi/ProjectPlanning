{"ast":null,"code":"import { isMatch, isValid, parseISO } from 'date-fns';\nexport var isNumeric = function (value) {\n  return !isNaN(parseFloat(value)) && isFinite(value);\n};\nexport var valuesAreNumeric = function (values) {\n  return values.every(isNumeric);\n};\nexport var isInteger = function (value) {\n  return Number.isInteger(value) || !isNaN(parseInt(value));\n};\nexport var valuesAreInteger = function (values) {\n  return values.every(isInteger);\n};\nexport var isBoolean = function (value) {\n  return typeof value === 'boolean';\n};\nexport var valuesAreBoolean = function (values) {\n  return values.every(isBoolean);\n};\nexport var isBooleanString = function (value) {\n  return ['true', 'false'].includes(value.toString().toLowerCase());\n};\nexport var valuesAreBooleanString = function (values) {\n  return values.every(isBooleanString);\n};\nexport var isString = function (value) {\n  return typeof value === 'string';\n};\nexport var valuesAreString = function (values) {\n  return values.every(isString);\n};\nvar HtmlRegexp = /<([A-Z][A-Z0-9]*)\\b[^>]*>(.*?)<\\/\\1>/i;\nexport var isHtml = function (value) {\n  return !value || HtmlRegexp.test(value);\n};\nexport var valuesAreHtml = function (values) {\n  return values.every(isHtml);\n};\nvar UrlRegexp = /http(s*):\\/\\/.*/i;\nexport var isUrl = function (value) {\n  return !value || UrlRegexp.test(value);\n};\nexport var valuesAreUrl = function (values) {\n  return values.every(isUrl);\n};\nvar ImageUrlRegexp = /http(s*):\\/\\/.*\\.(jpeg|jpg|jfif|pjpeg|pjp|png|svg|gif|webp|apng|bmp|ico|cur|tif|tiff)/i;\nexport var isImageUrl = function (value) {\n  return !value || ImageUrlRegexp.test(value);\n};\nexport var valuesAreImageUrl = function (values) {\n  return values.every(isImageUrl);\n};\n// This is a very simple regex to find emails\n// It is NOT meant to validate emails as the spec is way more complicated but is\n// enough for our inference needs\nvar EmailRegexp = /@{1}/;\nexport var isEmail = function (value) {\n  return !value || EmailRegexp.test(value);\n};\nexport var valuesAreEmail = function (values) {\n  return values.every(isEmail);\n};\nexport var isArray = function (value) {\n  return Array.isArray(value);\n};\nexport var valuesAreArray = function (values) {\n  return values.every(isArray);\n};\nexport var isDate = function (value) {\n  return !value || value instanceof Date;\n};\nexport var valuesAreDate = function (values) {\n  return values.every(isDate);\n};\nexport var isDateString = function (value) {\n  return !value || typeof value === 'string' && (isMatch(value, 'MM/dd/yyyy') || isMatch(value, 'MM/dd/yy') || isValid(parseISO(value)));\n};\nexport var valuesAreDateString = function (values) {\n  return values.every(isDateString);\n};\nexport var isObject = function (value) {\n  return Object.prototype.toString.call(value) === '[object Object]';\n};\nexport var valuesAreObject = function (values) {\n  return values.every(isObject);\n};","map":{"version":3,"names":["isMatch","isValid","parseISO","isNumeric","value","isNaN","parseFloat","isFinite","valuesAreNumeric","values","every","isInteger","Number","parseInt","valuesAreInteger","isBoolean","valuesAreBoolean","isBooleanString","includes","toString","toLowerCase","valuesAreBooleanString","isString","valuesAreString","HtmlRegexp","isHtml","test","valuesAreHtml","UrlRegexp","isUrl","valuesAreUrl","ImageUrlRegexp","isImageUrl","valuesAreImageUrl","EmailRegexp","isEmail","valuesAreEmail","isArray","Array","valuesAreArray","isDate","Date","valuesAreDate","isDateString","valuesAreDateString","isObject","Object","prototype","call","valuesAreObject"],"sources":["/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/ra-core/src/inference/assertions.ts"],"sourcesContent":["import { isMatch, isValid, parseISO } from 'date-fns';\n\nexport const isNumeric = (value: any) =>\n    !isNaN(parseFloat(value)) && isFinite(value);\nexport const valuesAreNumeric = (values: any[]) => values.every(isNumeric);\n\nexport const isInteger = (value: any) =>\n    Number.isInteger(value) || !isNaN(parseInt(value));\nexport const valuesAreInteger = (values: any[]) => values.every(isInteger);\n\nexport const isBoolean = (value: any) => typeof value === 'boolean';\nexport const valuesAreBoolean = (values: any[]) => values.every(isBoolean);\n\nexport const isBooleanString = (value: any) =>\n    ['true', 'false'].includes(value.toString().toLowerCase());\nexport const valuesAreBooleanString = (values: any[]) =>\n    values.every(isBooleanString);\n\nexport const isString = (value: any) => typeof value === 'string';\nexport const valuesAreString = (values: any[]) => values.every(isString);\n\nconst HtmlRegexp = /<([A-Z][A-Z0-9]*)\\b[^>]*>(.*?)<\\/\\1>/i;\nexport const isHtml = (value: any) => !value || HtmlRegexp.test(value);\nexport const valuesAreHtml = (values: any[]) => values.every(isHtml);\n\nconst UrlRegexp = /http(s*):\\/\\/.*/i;\nexport const isUrl = (value: any) => !value || UrlRegexp.test(value);\nexport const valuesAreUrl = (values: any[]) => values.every(isUrl);\n\nconst ImageUrlRegexp = /http(s*):\\/\\/.*\\.(jpeg|jpg|jfif|pjpeg|pjp|png|svg|gif|webp|apng|bmp|ico|cur|tif|tiff)/i;\nexport const isImageUrl = (value: any) => !value || ImageUrlRegexp.test(value);\nexport const valuesAreImageUrl = (values: any[]) => values.every(isImageUrl);\n\n// This is a very simple regex to find emails\n// It is NOT meant to validate emails as the spec is way more complicated but is\n// enough for our inference needs\nconst EmailRegexp = /@{1}/;\nexport const isEmail = (value: any) => !value || EmailRegexp.test(value);\nexport const valuesAreEmail = (values: any[]) => values.every(isEmail);\n\nexport const isArray = (value: any) => Array.isArray(value);\nexport const valuesAreArray = (values: any[]) => values.every(isArray);\n\nexport const isDate = (value: any) => !value || value instanceof Date;\nexport const valuesAreDate = (values: any[]) => values.every(isDate);\n\nexport const isDateString = (value: any) =>\n    !value ||\n    (typeof value === 'string' &&\n        (isMatch(value, 'MM/dd/yyyy') ||\n            isMatch(value, 'MM/dd/yy') ||\n            isValid(parseISO(value))));\n\nexport const valuesAreDateString = (values: any[]) =>\n    values.every(isDateString);\n\nexport const isObject = (value: any) =>\n    Object.prototype.toString.call(value) === '[object Object]';\nexport const valuesAreObject = (values: any[]) => values.every(isObject);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}