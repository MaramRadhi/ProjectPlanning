{"ast":null,"code":"var isMatchingReferencesError = function (matchingReferences) {\n  return matchingReferences && matchingReferences.error !== undefined;\n};\nexport var getStatusForInput = function (_a) {\n  var field = _a.field,\n    matchingReferences = _a.matchingReferences,\n    referenceRecord = _a.referenceRecord,\n    _b = _a.translate,\n    translate = _b === void 0 ? function (x) {\n      return x;\n    } : _b;\n  var matchingReferencesError = isMatchingReferencesError(matchingReferences) ? translate(matchingReferences.error, {\n    _: matchingReferences.error\n  }) : null;\n  var selectedReferenceError = field.value && !referenceRecord ? translate('ra.input.references.single_missing', {\n    _: 'ra.input.references.single_missing'\n  }) : null;\n  return {\n    waiting: field.value && selectedReferenceError && !matchingReferences || !field.value && !matchingReferences,\n    error: field.value && selectedReferenceError && matchingReferencesError || !field.value && matchingReferencesError ? field.value ? selectedReferenceError : matchingReferencesError : null,\n    warning: selectedReferenceError || matchingReferencesError,\n    choices: Array.isArray(matchingReferences) ? matchingReferences : [referenceRecord].filter(function (choice) {\n      return choice;\n    })\n  };\n};\nexport var REFERENCES_STATUS_READY = 'REFERENCES_STATUS_READY';\nexport var REFERENCES_STATUS_INCOMPLETE = 'REFERENCES_STATUS_INCOMPLETE';\nexport var REFERENCES_STATUS_EMPTY = 'REFERENCES_STATUS_EMPTY';\nexport var getSelectedReferencesStatus = function (field, referenceRecords) {\n  return !field.value || field.value.length === referenceRecords.length ? REFERENCES_STATUS_READY : referenceRecords.length > 0 ? REFERENCES_STATUS_INCOMPLETE : REFERENCES_STATUS_EMPTY;\n};\nexport var getStatusForArrayInput = function (_a) {\n  var field = _a.field,\n    matchingReferences = _a.matchingReferences,\n    referenceRecords = _a.referenceRecords,\n    _b = _a.translate,\n    translate = _b === void 0 ? function (x) {\n      return x;\n    } : _b;\n  // selectedReferencesDataStatus can be \"empty\" (no data was found for references from input.value)\n  // or \"incomplete\" (Not all of the reference data was found)\n  // or \"ready\" (all references data was found or there is no references from input.value)\n  var selectedReferencesDataStatus = getSelectedReferencesStatus(field, referenceRecords);\n  var matchingReferencesError = isMatchingReferencesError(matchingReferences) ? translate(matchingReferences.error, {\n    _: matchingReferences.error\n  }) : null;\n  var choices = Array.isArray(matchingReferences) ? referenceRecords.concat(matchingReferences.filter(function (choice) {\n    return referenceRecords.findIndex(function (c) {\n      return c.id === choice.id;\n    }) === -1;\n  })) : referenceRecords;\n  return {\n    waiting: !matchingReferences && field.value && selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY || !matchingReferences && !field.value,\n    error: matchingReferencesError && (!field.value || field.value && selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY) ? translate('ra.input.references.all_missing', {\n      _: 'ra.input.references.all_missing'\n    }) : null,\n    warning: matchingReferencesError || field.value && selectedReferencesDataStatus !== REFERENCES_STATUS_READY ? matchingReferencesError || translate('ra.input.references.many_missing', {\n      _: 'ra.input.references.many_missing'\n    }) : null,\n    choices: choices\n  };\n};","map":{"version":3,"names":["isMatchingReferencesError","matchingReferences","error","undefined","getStatusForInput","_a","field","referenceRecord","_b","translate","x","matchingReferencesError","_","selectedReferenceError","value","waiting","warning","choices","Array","isArray","filter","choice","REFERENCES_STATUS_READY","REFERENCES_STATUS_INCOMPLETE","REFERENCES_STATUS_EMPTY","getSelectedReferencesStatus","referenceRecords","length","getStatusForArrayInput","selectedReferencesDataStatus","concat","findIndex","c","id"],"sources":["/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/ra-core/src/controller/input/referenceDataStatus.ts"],"sourcesContent":["import { RaRecord, Translate } from '../../types';\nimport { MatchingReferencesError } from './types';\nimport { ControllerRenderProps } from 'react-hook-form';\n\ninterface GetStatusForInputParams<RecordType extends RaRecord = RaRecord> {\n    field: Pick<ControllerRenderProps, 'value'>;\n    matchingReferences: RecordType[] | MatchingReferencesError;\n    referenceRecord: RecordType;\n    translate: Translate;\n}\n\nconst isMatchingReferencesError = (\n    matchingReferences?: any\n): matchingReferences is MatchingReferencesError =>\n    matchingReferences && matchingReferences.error !== undefined;\n\nexport const getStatusForInput = <RecordType extends RaRecord = RaRecord>({\n    field,\n    matchingReferences,\n    referenceRecord,\n    translate = x => x,\n}: GetStatusForInputParams<RecordType>) => {\n    const matchingReferencesError = isMatchingReferencesError(\n        matchingReferences\n    )\n        ? translate(matchingReferences.error, {\n              _: matchingReferences.error,\n          })\n        : null;\n    const selectedReferenceError =\n        field.value && !referenceRecord\n            ? translate('ra.input.references.single_missing', {\n                  _: 'ra.input.references.single_missing',\n              })\n            : null;\n\n    return {\n        waiting:\n            (field.value && selectedReferenceError && !matchingReferences) ||\n            (!field.value && !matchingReferences),\n        error:\n            (field.value &&\n                selectedReferenceError &&\n                matchingReferencesError) ||\n            (!field.value && matchingReferencesError)\n                ? field.value\n                    ? selectedReferenceError\n                    : matchingReferencesError\n                : null,\n        warning: selectedReferenceError || matchingReferencesError,\n        choices: Array.isArray(matchingReferences)\n            ? matchingReferences\n            : [referenceRecord].filter(choice => choice),\n    };\n};\n\nexport const REFERENCES_STATUS_READY = 'REFERENCES_STATUS_READY';\nexport const REFERENCES_STATUS_INCOMPLETE = 'REFERENCES_STATUS_INCOMPLETE';\nexport const REFERENCES_STATUS_EMPTY = 'REFERENCES_STATUS_EMPTY';\n\nexport const getSelectedReferencesStatus = <RecordType extends RaRecord = any>(\n    field: Pick<ControllerRenderProps, 'value'>,\n    referenceRecords: RecordType[]\n) =>\n    !field.value || field.value.length === referenceRecords.length\n        ? REFERENCES_STATUS_READY\n        : referenceRecords.length > 0\n        ? REFERENCES_STATUS_INCOMPLETE\n        : REFERENCES_STATUS_EMPTY;\n\ninterface GetStatusForArrayInputParams<RecordType extends RaRecord = any> {\n    field: ControllerRenderProps;\n    matchingReferences: RecordType[] | MatchingReferencesError;\n    referenceRecords: RecordType[];\n    translate: Translate;\n}\n\nexport const getStatusForArrayInput = <RecordType extends RaRecord = any>({\n    field,\n    matchingReferences,\n    referenceRecords,\n    translate = x => x,\n}: GetStatusForArrayInputParams<RecordType>) => {\n    // selectedReferencesDataStatus can be \"empty\" (no data was found for references from input.value)\n    // or \"incomplete\" (Not all of the reference data was found)\n    // or \"ready\" (all references data was found or there is no references from input.value)\n    const selectedReferencesDataStatus = getSelectedReferencesStatus(\n        field,\n        referenceRecords\n    );\n\n    const matchingReferencesError = isMatchingReferencesError(\n        matchingReferences\n    )\n        ? translate(matchingReferences.error, {\n              _: matchingReferences.error,\n          })\n        : null;\n\n    const choices = Array.isArray(matchingReferences)\n        ? referenceRecords.concat(\n              matchingReferences.filter(\n                  choice =>\n                      referenceRecords.findIndex(c => c.id === choice.id) === -1\n              )\n          )\n        : referenceRecords;\n\n    return {\n        waiting:\n            (!matchingReferences &&\n                field.value &&\n                selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY) ||\n            (!matchingReferences && !field.value),\n        error:\n            matchingReferencesError &&\n            (!field.value ||\n                (field.value &&\n                    selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY))\n                ? translate('ra.input.references.all_missing', {\n                      _: 'ra.input.references.all_missing',\n                  })\n                : null,\n        warning:\n            matchingReferencesError ||\n            (field.value &&\n                selectedReferencesDataStatus !== REFERENCES_STATUS_READY)\n                ? matchingReferencesError ||\n                  translate('ra.input.references.many_missing', {\n                      _: 'ra.input.references.many_missing',\n                  })\n                : null,\n        choices,\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}