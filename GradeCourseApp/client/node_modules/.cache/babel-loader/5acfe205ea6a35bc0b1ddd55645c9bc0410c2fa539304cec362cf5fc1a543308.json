{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport HttpError from './HttpError';\nimport { stringify } from 'query-string';\nexport var createHeadersFromOptions = function (options) {\n  var requestHeaders = options.headers || new Headers({\n    Accept: 'application/json'\n  });\n  if (!requestHeaders.has('Content-Type') && !(options && (!options.method || options.method === 'GET')) && !(options && options.body && options.body instanceof FormData)) {\n    requestHeaders.set('Content-Type', 'application/json');\n  }\n  if (options.user && options.user.authenticated && options.user.token) {\n    requestHeaders.set('Authorization', options.user.token);\n  }\n  return requestHeaders;\n};\n/**\n * Utility function to make HTTP calls. It's similar to the HTML5 `fetch()`, except it handles JSON decoding and HTTP error codes automatically.\n *\n * @param url the URL to call\n * @param options the options to pass to the HTTP call\n * @param options.user the user object, used for the Authorization header\n * @param options.user.token the token to pass as the Authorization header\n * @param options.user.authenticated whether the user is authenticated or not (the Authorization header will be set only if this is true)\n * @param options.headers the headers to pass to the HTTP call\n *\n * @returns {Promise} the Promise for a response object containing the following properties:\n * - status: the HTTP status code\n * - headers: the HTTP headers\n * - body: the response body\n * - json: the response body parsed as JSON\n */\nexport var fetchJson = function (url, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var requestHeaders = createHeadersFromOptions(options);\n  return fetch(url, __assign(__assign({}, options), {\n    headers: requestHeaders\n  })).then(function (response) {\n    return response.text().then(function (text) {\n      return {\n        status: response.status,\n        statusText: response.statusText,\n        headers: response.headers,\n        body: text\n      };\n    });\n  }).then(function (_a) {\n    var status = _a.status,\n      statusText = _a.statusText,\n      headers = _a.headers,\n      body = _a.body;\n    var json;\n    try {\n      json = JSON.parse(body);\n    } catch (e) {\n      // not json, no big deal\n    }\n    if (status < 200 || status >= 300) {\n      return Promise.reject(new HttpError(json && json.message || statusText, status, json));\n    }\n    return Promise.resolve({\n      status: status,\n      headers: headers,\n      body: body,\n      json: json\n    });\n  });\n};\nexport var queryParameters = stringify;\nvar isValidObject = function (value) {\n  if (!value) {\n    return false;\n  }\n  var isArray = Array.isArray(value);\n  var isBuffer = typeof Buffer !== 'undefined' && Buffer.isBuffer(value);\n  var isObject = Object.prototype.toString.call(value) === '[object Object]';\n  var hasKeys = !!Object.keys(value).length;\n  return !isArray && !isBuffer && isObject && hasKeys;\n};\nexport var flattenObject = function (value, path) {\n  var _a;\n  if (path === void 0) {\n    path = [];\n  }\n  if (isValidObject(value)) {\n    return Object.assign.apply(Object, __spreadArray([{}], Object.keys(value).map(function (key) {\n      return flattenObject(value[key], path.concat([key]));\n    }), false));\n  } else {\n    return path.length ? (_a = {}, _a[path.join('.')] = value, _a) : value;\n  }\n};","map":{"version":3,"names":["HttpError","stringify","createHeadersFromOptions","options","requestHeaders","headers","Headers","Accept","has","method","body","FormData","set","user","authenticated","token","fetchJson","url","fetch","__assign","then","response","text","status","statusText","_a","json","JSON","parse","e","Promise","reject","message","resolve","queryParameters","isValidObject","value","isArray","Array","isBuffer","Buffer","isObject","Object","prototype","toString","call","hasKeys","keys","length","flattenObject","path","assign","apply","__spreadArray","map","key","concat","join"],"sources":["/Users/imrun10/Documents/GitHub/GradeCourseApp/client/node_modules/ra-core/src/dataProvider/fetch.ts"],"sourcesContent":["import HttpError from './HttpError';\nimport { stringify } from 'query-string';\n\nexport interface Options extends RequestInit {\n    user?: {\n        authenticated?: boolean;\n        token?: string;\n    };\n}\n\nexport const createHeadersFromOptions = (options: Options): Headers => {\n    const requestHeaders = (options.headers ||\n        new Headers({\n            Accept: 'application/json',\n        })) as Headers;\n    if (\n        !requestHeaders.has('Content-Type') &&\n        !(options && (!options.method || options.method === 'GET')) &&\n        !(options && options.body && options.body instanceof FormData)\n    ) {\n        requestHeaders.set('Content-Type', 'application/json');\n    }\n    if (options.user && options.user.authenticated && options.user.token) {\n        requestHeaders.set('Authorization', options.user.token);\n    }\n\n    return requestHeaders;\n};\n\n/**\n * Utility function to make HTTP calls. It's similar to the HTML5 `fetch()`, except it handles JSON decoding and HTTP error codes automatically.\n *\n * @param url the URL to call\n * @param options the options to pass to the HTTP call\n * @param options.user the user object, used for the Authorization header\n * @param options.user.token the token to pass as the Authorization header\n * @param options.user.authenticated whether the user is authenticated or not (the Authorization header will be set only if this is true)\n * @param options.headers the headers to pass to the HTTP call\n *\n * @returns {Promise} the Promise for a response object containing the following properties:\n * - status: the HTTP status code\n * - headers: the HTTP headers\n * - body: the response body\n * - json: the response body parsed as JSON\n */\nexport const fetchJson = (url, options: Options = {}) => {\n    const requestHeaders = createHeadersFromOptions(options);\n\n    return fetch(url, { ...options, headers: requestHeaders })\n        .then(response =>\n            response.text().then(text => ({\n                status: response.status,\n                statusText: response.statusText,\n                headers: response.headers,\n                body: text,\n            }))\n        )\n        .then(({ status, statusText, headers, body }) => {\n            let json;\n            try {\n                json = JSON.parse(body);\n            } catch (e) {\n                // not json, no big deal\n            }\n            if (status < 200 || status >= 300) {\n                return Promise.reject(\n                    new HttpError(\n                        (json && json.message) || statusText,\n                        status,\n                        json\n                    )\n                );\n            }\n            return Promise.resolve({ status, headers, body, json });\n        });\n};\n\nexport const queryParameters = stringify;\n\nconst isValidObject = value => {\n    if (!value) {\n        return false;\n    }\n\n    const isArray = Array.isArray(value);\n    const isBuffer = typeof Buffer !== 'undefined' && Buffer.isBuffer(value);\n    const isObject =\n        Object.prototype.toString.call(value) === '[object Object]';\n    const hasKeys = !!Object.keys(value).length;\n\n    return !isArray && !isBuffer && isObject && hasKeys;\n};\n\nexport const flattenObject = (value, path = []) => {\n    if (isValidObject(value)) {\n        return Object.assign(\n            {},\n            ...Object.keys(value).map(key =>\n                flattenObject(value[key], path.concat([key]))\n            )\n        );\n    } else {\n        return path.length ? { [path.join('.')]: value } : value;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}